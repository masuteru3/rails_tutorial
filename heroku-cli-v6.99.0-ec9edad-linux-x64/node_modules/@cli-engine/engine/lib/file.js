"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = require("fs-extra");
const path = require("path");
const deps_1 = require("./deps");
const debug = require('debug')('cli:file');
function exists(f) {
    // debug('exists', f)
    // @ts-ignore
    return fs.exists(f);
}
exports.exists = exists;
function existsSync(f) {
    return fs.existsSync(f);
}
exports.existsSync = existsSync;
const jsonFiles = {};
function fetchJSONFile(f) {
    if (!jsonFiles[f]) {
        debug('fetchJSONFile', f);
        jsonFiles[f] = fs.readJSON(f);
    }
    return jsonFiles[f];
}
exports.fetchJSONFile = fetchJSONFile;
function rename(from, to) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug('rename', from, to);
        return fs.rename(from, to);
    });
}
exports.rename = rename;
function mkdirp(dir) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug('mkdirp', dir);
        return fs.mkdirp(dir);
    });
}
exports.mkdirp = mkdirp;
function outputFile(file, data, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug('outputFile', file);
        return fs.outputFile(file, data, options);
    });
}
exports.outputFile = outputFile;
function outputFileSync(p, body) {
    debug('outputFileSync');
    return fs.outputFileSync(p, body);
}
exports.outputFileSync = outputFileSync;
function outputJSON(file, data, options = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug('outputJSON', file);
        return fs.outputJSON(file, data, Object.assign({ spaces: 2 }, options));
    });
}
exports.outputJSON = outputJSON;
function readJSON(file) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug('readJSON', file);
        return fs.readJSON(file);
    });
}
exports.readJSON = readJSON;
function readFile(file) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug('read', file);
        return fs.readFile(file, 'utf8');
    });
}
exports.readFile = readFile;
function remove(file) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!(yield exists(file)))
            return;
        debug('remove', file);
        return fs.remove(file);
    });
}
exports.remove = remove;
function stat(file) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return fs.stat(file);
    });
}
exports.stat = stat;
function open(path, flags, mode) {
    debug('open', path, flags, mode);
    return fs.open(path, flags, mode);
}
exports.open = open;
function write(fd, data) {
    debug('write', fd);
    // @ts-ignore
    return fs.write(fd, data);
}
exports.write = write;
function walk(root, opts = {}) {
    debug('walk', root);
    return new Promise((resolve, reject) => {
        const items = [];
        deps_1.default
            .klaw(root, Object.assign({}, opts, { depthLimit: 10000 }))
            .on('data', f => items.push(f))
            .on('error', reject)
            .on('end', () => resolve(items));
    });
}
exports.walk = walk;
function ls(dir) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let files = yield fs.readdir(dir);
        let paths = files.map(f => path.join(dir, f));
        return Promise.all(paths.map(path => fs.stat(path).then(stat => ({ path, stat }))));
    });
}
exports.ls = ls;
function cleanup(dir) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let files;
        try {
            files = yield ls(dir);
        }
        catch (err) {
            if (err.code === 'ENOENT')
                return;
            throw err;
        }
        let dirs = files.filter(f => f.stat.isDirectory()).map(f => f.path);
        for (let p of dirs.map(cleanup))
            yield p;
        files = yield ls(dir);
        if (!files.length)
            yield remove(dir);
    });
}
exports.cleanup = cleanup;
function symlink(src, dst) {
    return fs.symlink(src, dst);
}
exports.symlink = symlink;
function utimesSync(p, atime, mtime) {
    debug('utimeSync');
    return fs.utimesSync(p, atime, mtime);
}
exports.utimesSync = utimesSync;
function touch(p) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug('touch', p);
        try {
            return yield fs.utimes(p, new Date(), new Date());
        }
        catch (err) {
            return outputFile(p, '');
        }
    });
}
exports.touch = touch;
function mkdirpSync(p) {
    debug('mkdirpSync', p);
    return fs.mkdirpSync(p);
}
exports.mkdirpSync = mkdirpSync;
function emptyDir(p) {
    debug('emptyDir', p);
    return fs.emptyDir(p);
}
exports.emptyDir = emptyDir;
