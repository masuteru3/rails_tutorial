"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const help_1 = require("@cli-engine/command/lib/help");
const cli_ux_1 = require("cli-ux");
const path = require("path");
const rwlockfile_1 = require("rwlockfile");
const ts_lodash_1 = require("ts-lodash");
const deps_1 = require("../deps");
const topic_1 = require("../topic");
class Plugin {
    constructor(opts) {
        this.config = opts.config;
        this.root = opts.root;
        this.pjson = opts.pjson;
        if (!this.pjson['cli-engine'])
            this.pjson['cli-engine'] = {};
        this.name = this.name || this.pjson.name;
        this.version = this.version || this.pjson.version;
        let cacheKey = [this.config.version, this.version].join(path.sep);
        let cacheFile = path.join(this.config.cacheDir, 'plugins', [opts.type, this.name + '.json'].join(path.sep));
        this.cache = new deps_1.default.PluginManifest({ file: cacheFile, invalidate: cacheKey, name: this.name });
        this.debug = require('debug')(`cli:plugins:${[opts.type, this.name, this.version].join(':')}`);
        this.lock = new rwlockfile_1.default(cacheFile, { ifLocked: () => cli_ux_1.default.action.start(`Plugin ${this.name} is updating`) });
        this.type = opts.type;
    }
    load() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.result)
                return this.result;
            this.result = {
                commands: yield this.commands(),
                topics: yield this.topics(),
            };
            return this.result;
        });
    }
    reset(reload = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.cache.reset();
            if (reload)
                yield this.load();
        });
    }
    findCommand(id, must = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let cmd = yield this.findCommandInModule(id);
            if (!cmd)
                cmd = yield this.findCommandInDir(id);
            if (cmd) {
                cmd = this.addPluginToCommand(cmd);
                return cmd;
            }
            if (must)
                throw new Error(`${id} not found`);
        });
    }
    commands() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let cacheFetchCallback = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.debug('fetching commands');
                const commands = yield deps_1.default
                    .assync([this.commandsFromModule(), this.commandsFromDir()])
                    .flatMap();
                const r = yield Promise.all(commands);
                return r;
            });
            let cache = yield this.cacheFetch('commands', cacheFetchCallback);
            if (!cache)
                cache = yield cacheFetchCallback();
            return cache.map(c => (Object.assign({}, c, { fetchCommand: () => this.findCommand(c.id, true), run: (argv) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    // await this.lock.add('read', { reason: 'running plugin' })
                    let cmd = yield this.findCommand(c.id, true);
                    let res;
                    let base = cmd._base;
                    let legacy = cmd.legacy;
                    if (!legacy && base && base.startsWith('@oclif')) {
                        res = yield cmd.run(argv.slice(3), { root: cmd.plugin.root, devPlugins: false });
                    }
                    else if ((!legacy && !c._version) || c._version === '0.0.0') {
                        // this.debug('legacy @cli-engine/command version', c._version)
                        res = yield cmd.run(Object.assign({}, this.config, { argv: argv.slice(4) }));
                    }
                    else if (!legacy && deps_1.default.semver.lt(c._version || '', '10.0.0')) {
                        // this.debug('legacy @cli-engine/command version', c._version)
                        let cvrtConfig = this.convertConfig(this.config);
                        res = yield cmd.run(Object.assign({}, cvrtConfig, { argv: argv.slice(1) }));
                    }
                    else if (!legacy && deps_1.default.semver.lt(c._version || '', '11.0.0-beta.0')) {
                        // this.debug(`legacy @cli-engine/command version`, c._version)
                        res = yield cmd.run(Object.assign({}, this.config, { argv: argv.slice(2) }));
                    }
                    else {
                        res = yield cmd.run(argv.slice(3), this.config);
                    }
                    // await this.lock.remove('read')
                    return res;
                }) })));
        });
    }
    topics() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const cache = yield this.cacheFetch('topics', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.debug('fetching topics');
                const m = yield this.fetchModule();
                if (!m)
                    return [];
                return m.topics;
            }));
            let pjson = this.pjson.oclif || this.pjson['cli-engine'];
            let pjsonTopics = pjson.topics;
            if (pjsonTopics)
                return cache.concat(topic_1.topicsToArray(pjsonTopics));
            return cache;
        });
    }
    get commandsDir() {
        let pjson = this.pjson.oclif || this.pjson['cli-engine'];
        let d = pjson.commands;
        if (d)
            return path.join(this.root, d);
    }
    commandIDsFromDir() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const d = this.commandsDir;
            if (!d)
                return Promise.resolve([]);
            this.debug(`loading IDs from ${d}`);
            const files = yield deps_1.default.globby(['**/*.+(js|ts)', '!**/*.+(d.ts|test.ts|test.js)'], { nodir: true, cwd: d });
            const ids = files
                .map(path.parse)
                .map((p) => ts_lodash_1.default.compact([...p.dir.split(path.sep), p.name === 'index' ? '' : p.name]).join(':'));
            this.debug(`commandIDsFromDir dir:%s, ids:%o`, d, ids);
            return ids;
        });
    }
    commandPath(id) {
        if (!this.commandsDir)
            throw new Error('commandsDir not set');
        return require.resolve(path.join(this.commandsDir, id.split(':').join(path.sep)));
    }
    commandsFromModule() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const m = yield this.fetchModule();
            if (!m)
                return [];
            return deps_1.default.assync(m.commands).map(c => this.commandInfoFromICommand(c));
        });
    }
    commandsFromDir() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ids = yield this.commandIDsFromDir();
            return deps_1.default
                .assync(ids)
                .map(id => ({ cmd: this.findCommandInDir(id), id }))
                .map(({ cmd, id }) => this.commandInfoFromICommand(cmd, id));
        });
    }
    commandInfoFromICommand(icommand, id = icommand.id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let help = yield (icommand.buildHelp ? icommand.buildHelp(this.config) : this.buildHelp(icommand));
            let helpLine = yield (icommand.buildHelpLine ? icommand.buildHelpLine(this.config) : this.buildHelpLine(icommand));
            return {
                id,
                _version: icommand._version,
                description: icommand.description,
                usage: icommand.usage,
                plugin: { name: this.name, version: this.version },
                hidden: icommand.hidden,
                aliases: icommand.aliases || [],
                help,
                helpLine,
            };
        });
    }
    buildHelp(c) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new help_1.Help(this.config).command(c);
        });
    }
    buildHelpLine(c) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new help_1.Help(this.config).commandLine(c);
        });
    }
    findCommandInDir(id) {
        let c = deps_1.default.util.undefault(require(this.commandPath(id)));
        if (!c.id)
            c.id = id;
        return c;
    }
    findCommandInModule(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const m = yield this.fetchModule();
            if (!m)
                return;
            return m.commands.find(c => c.id === id);
        });
    }
    addPluginToCommand(cmd) {
        cmd.plugin = {
            type: this.type,
            root: this.root,
            name: this.name,
            version: this.version,
        };
        return cmd;
    }
    fetchModule() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.pjson.main)
                return;
            if (this._module)
                return this._module;
            return (this._module = (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.debug(`requiring ${this.name}@${this.version}`);
                const m = Object.assign({ commands: [], topics: [] }, require(path.join(this.root, this.pjson.main)));
                if (m.topic)
                    m.topics.push(m.topic);
                m.commands = m.commands.map(deps_1.default.util.undefault);
                const hooks = new deps_1.default.Hooks(this.config);
                yield hooks.run('plugins:parse', { module: m, pjson: this.pjson });
                let legacy = new deps_1.default.PluginLegacy(this.config);
                return legacy.convert(m);
            }))());
        });
    }
    cacheFetch(key, fn) {
        return this.skipCache ? fn() : this.cache.fetch(key, fn);
    }
    convertConfig(config) {
        return {
            argv: config.argv,
            bin: config.bin,
            channel: config.channel,
            name: config.name,
            reexecBin: config.reexecBin,
            root: config.root,
            version: config.version,
            arch: config.arch,
            platform: config.platform,
            windows: config.windows,
            corePlugins: config.corePlugins,
            defaultCommand: config.defaultCommand,
            hooks: config.hooks,
            npmRegistry: config.npmRegistry,
            topics: config.topics,
            userPluginsEnabled: config.userPluginsEnabled,
            s3: config.s3,
            dirname: config.dirname,
            home: config.home,
            cacheDir: config.cacheDir,
            configDir: config.configDir,
            dataDir: config.dataDir,
            errlog: config.errlog,
            pjson: config.pjson,
            userAgent: config.userAgent,
            commandsDir: config.commandsDir,
            updateDisabled: config.updateDisabled,
            shell: config.shell,
            debug: config.debug,
        };
    }
}
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'write')
], Plugin.prototype, "reset", null);
exports.Plugin = Plugin;
