"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@cli-engine/command");
const color_1 = require("@heroku-cli/color");
const Heroku = require("@heroku-cli/command");
const ts_lodash_1 = require("ts-lodash");
const util_1 = require("util");
const deps_1 = require("../deps");
const debug = require('debug')('cli:legacy');
class PluginLegacy {
    constructor(_) { }
    convert(m) {
        m.commands = this.convertCommands(m.commands);
        return m;
    }
    convertCommands(c) {
        return c.map(c => this.convertCommand(c));
    }
    convertCommand(c) {
        if (this.isICommand(c))
            return this.convertFromICommand(c);
        if (this.isV5Command(c))
            return this.convertFromV5(c);
        if (this.isFlowCommand(c))
            return this.convertFromFlow(c);
        debug(c);
        throw new Error(`Invalid command: ${util_1.inspect(c)}`);
    }
    convertFromICommand(c) {
        if (!c.id)
            c.id = ts_lodash_1.default.compact([c.topic, c.command]).join(':');
        return c;
    }
    convertFromFlow(c) {
        if (!c.id)
            c.id = ts_lodash_1.default.compact([c.topic, c.command]).join(':');
        c._version = c._version || '0.0.0';
        return c;
    }
    convertFromV5(c) {
        class V5 extends Heroku.Command {
            run() {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const ctx = {
                        version: this.config.userAgent,
                        supportsColor: color_1.color.enabled,
                        auth: {},
                        debug: !!this.config.debug,
                        debugHeaders: this.config.debug > 1 || ['1', 'true'].includes(process.env.HEROKU_DEBUG_HEADERS),
                        flags: this.flags,
                        args: c.variableArgs ? this.argv : this.args,
                        app: this.flags.app,
                        org: this.flags.org,
                        team: this.flags.team,
                        config: this.config,
                        apiUrl: Heroku.vars.apiUrl,
                        herokuDir: this.config.cacheDir,
                        apiToken: this.heroku.auth,
                        apiHost: Heroku.vars.apiHost,
                        gitHost: Heroku.vars.gitHost,
                        httpGitHost: Heroku.vars.httpGitHost,
                        cwd: process.cwd(),
                    };
                    ctx.auth.password = ctx.apiToken;
                    const ansi = require('ansi-escapes');
                    process.once('exit', () => {
                        if (process.stderr.isTTY) {
                            process.stderr.write(ansi.cursorShow);
                        }
                    });
                    return c.run(ctx);
                });
            }
        }
        V5.id = ts_lodash_1.default.compact([c.topic, c.command]).join(':');
        V5.description = c.description;
        V5.hidden = !!c.hidden;
        V5.args = (c.args || []).map(a => (Object.assign({}, a, { required: a.required !== false && !a.optional })));
        V5.flags = convertFlagsFromV5(c.flags);
        V5.variableArgs = !!c.variableArgs;
        V5.help = c.help;
        V5.aliases = c.aliases || [];
        V5.usage = c.usage;
        V5.legacy = true;
        if (c.needsApp || c.wantsApp) {
            V5.flags.app = Heroku.flags.app({ required: !!c.needsApp });
            V5.flags.remote = Heroku.flags.remote();
        }
        if (c.needsOrg || c.wantsOrg) {
            let opts = { required: !!c.needsOrg, hidden: false, description: 'team to use' };
            if (!V5.flags.team)
                V5.flags.team = Heroku.flags.team(opts);
            if (!V5.flags.org) {
                const org = Object.assign({}, V5.flags.team);
                org.char = 'o';
                V5.flags.org = org;
            }
        }
        return V5;
    }
    isICommand(command) {
        let c = command;
        if (!c._version)
            return false;
        return deps_1.default.semver.gte(c._version, '11.0.0');
    }
    isV5Command(command) {
        let c = command;
        return !!(typeof c === 'object');
    }
    isFlowCommand(command) {
        let c = command;
        return typeof c === 'function';
        // if (c._version && deps.semver.lt(c._version, '11.0.0')) return true
    }
}
exports.PluginLegacy = PluginLegacy;
function convertFlagsFromV5(flags) {
    if (!flags)
        return {};
    if (!Array.isArray(flags))
        return flags;
    return flags.reduce((flags, flag) => {
        let opts = {
            char: flag.char,
            description: flag.description,
            hidden: flag.hidden,
            required: flag.required || flag.optional === false,
            parse: flag.parse,
            default: flag.default,
        };
        for (let [k, v] of deps_1.default.util.objEntries(opts)) {
            if (v === undefined)
                delete opts[k];
        }
        if (!opts.parse)
            delete opts.parse;
        flags[flag.name] = flag.hasValue ? command_1.flags.string(opts) : command_1.flags.boolean(opts);
        return flags;
    }, {});
}
