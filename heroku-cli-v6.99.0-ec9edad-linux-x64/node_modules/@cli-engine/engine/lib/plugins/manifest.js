"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const loadJSON = require("load-json-file");
const deps_1 = require("../deps");
class PluginManifest {
    constructor(opts) {
        this.needsSave = false;
        this.file = opts.file;
        this.invalidate = opts.invalidate;
        this.name = opts.name;
        this.debug = require('debug')(`cli:manifest:${this.name}`);
    }
    save() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.init();
            if (!this.needsSave)
                return;
            this.needsSave = false;
            this.debug('saving');
            if (!(yield this.canWrite())) {
                throw new Error(`manifest file ${this.file} modified, cannot save`);
            }
            yield deps_1.default.file.outputJSON(this.file, this.body);
            delete this.body;
            delete this.mtime;
        });
    }
    fetch(key, fn) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.init();
            let v = yield this.get(key);
            if (!v) {
                this.debug('fetching', key);
                const value = yield fn();
                try {
                    yield this.set(key, value);
                    if (yield this.canWrite())
                        yield this.save();
                }
                catch (err) {
                    this.debug(err);
                    return value;
                }
            }
            return yield this.get(key);
        });
    }
    get(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.init();
            return this.body.manifest[key];
        });
    }
    set(key, v) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.debug('set', key);
            if (!key)
                throw new Error('key is empty');
            yield this.init();
            this.body.manifest[key] = v;
            this.needsSave = true;
            return this.body.manifest[key];
        });
    }
    reset() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.debug('reset');
            yield deps_1.default.file.remove(this.file);
            delete this.body;
            this.needsSave = false;
        });
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.saving;
            if (this.body)
                return this.body;
            this.body = (yield this.read()) || {
                invalidate: this.invalidate,
                manifest: {},
            };
        });
    }
    read() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                this.mtime = yield this.getLastUpdated();
                let body = yield loadJSON(this.file);
                if (body.invalidate !== this.invalidate) {
                    this.debug('manifest version mismatch');
                    return;
                }
                if (!body.manifest)
                    this.body.manifest = {};
                return body;
            }
            catch (err) {
                this.debug(err);
                yield deps_1.default.file.remove(this.file);
            }
        });
    }
    canWrite() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.mtime)
                return true;
            return (yield this.getLastUpdated()) === this.mtime;
        });
    }
    getLastUpdated() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const stat = yield deps_1.default.file.stat(this.file);
                return stat.mtime.getTime();
            }
            catch (err) {
                if (err.code !== 'ENOENT')
                    throw err;
            }
        });
    }
}
exports.PluginManifest = PluginManifest;
