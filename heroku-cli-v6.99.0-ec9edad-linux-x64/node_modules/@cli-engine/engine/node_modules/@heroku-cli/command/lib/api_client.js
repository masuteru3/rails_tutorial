"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const url = require("url");
const deps_1 = require("./deps");
const vars_1 = require("./vars");
class HerokuAPIError extends Error {
    constructor(httpError) {
        let options = httpError.body;
        if (!options.message)
            throw httpError;
        let info = [];
        if (options.id)
            info.push(`Error ID: ${options.id}`);
        if (options.app && options.app.name)
            info.push(`App: ${options.app.name}`);
        if (options.url)
            info.push(`See ${options.url} for more information.`);
        if (info.length)
            super([options.message, ''].concat(info).join('\n'));
        else
            super(options.message);
        this.http = httpError;
        this.body = options;
    }
}
exports.HerokuAPIError = HerokuAPIError;
class APIClient {
    constructor(config, options = {}) {
        this.config = config;
        this.options = options;
        this.config = config;
        if (options.required === undefined)
            options.required = true;
        options.preauth = options.preauth !== false;
        this.options = options;
        let apiUrl = url.URL ? new url.URL(vars_1.vars.apiUrl) : url.parse(vars_1.vars.apiUrl);
        let envHeaders = JSON.parse(process.env.HEROKU_HEADERS || '{}');
        this.preauthPromises = {};
        let auth = this.auth;
        let self = this;
        this.http = class APIHTTPClient extends deps_1.default.HTTP.HTTP {
            static get defaultOptions() {
                let opts = Object.assign({}, super.defaultOptions, { host: apiUrl.host, headers: Object.assign({}, super.defaultOptions.headers, { accept: 'application/vnd.heroku+json; version=3', 'user-agent': `heroku-cli/${self.config.version} ${self.config.platform}` }, envHeaders) });
                if (auth)
                    opts.headers.authorization = `Bearer ${auth}`;
                return opts;
            }
            static twoFactorRetry(err, url, opts = {}, retries = 3) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const app = err.body.app ? err.body.app.name : null;
                    if (!app || !options.preauth) {
                        opts.headers = opts.headers || {};
                        opts.headers['Heroku-Two-Factor-Code'] = yield self.twoFactorPrompt();
                        return this.request(url, opts, retries);
                    }
                    else {
                        // if multiple requests are run in parallel for the same app, we should
                        // only preauth for the first so save the fact we already preauthed
                        if (!self.preauthPromises[app]) {
                            self.preauthPromises[app] = self.twoFactorPrompt().then(factor => self.preauth(app, factor));
                        }
                        yield self.preauthPromises[app];
                        return this.request(url, opts, retries);
                    }
                });
            }
            static request(url, opts = {}, retries = 3) {
                const _super = name => super[name];
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    retries--;
                    try {
                        return yield _super("request").call(this, url, opts);
                    }
                    catch (err) {
                        if (!(err instanceof deps_1.default.HTTP.HTTPError))
                            throw err;
                        if (retries > 0) {
                            if (err.http.statusCode === 403 && err.body.id === 'two_factor') {
                                return this.twoFactorRetry(err, url, opts, retries);
                            }
                        }
                        throw new HerokuAPIError(err);
                    }
                });
            }
        };
    }
    get twoFactorMutex() {
        if (!this._twoFactorMutex) {
            this._twoFactorMutex = new deps_1.default.Mutex();
        }
        return this._twoFactorMutex;
    }
    get auth() {
        if (process.env.HEROKU_API_TOKEN)
            deps_1.default.cli.warn('HEROKU_API_TOKEN is set but you probably meant HEROKU_API_KEY');
        let auth = process.env.HEROKU_API_KEY;
        if (!auth) {
            deps_1.default.netrc.loadSync();
            auth = deps_1.default.netrc.machines[vars_1.vars.apiHost] && deps_1.default.netrc.machines[vars_1.vars.apiHost].password;
        }
        return auth;
    }
    twoFactorPrompt() {
        deps_1.default.yubikey.enable();
        return this.twoFactorMutex.synchronize(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                let factor = yield deps_1.default.cli.prompt('Two-factor code', { type: 'mask' });
                deps_1.default.yubikey.disable();
                return factor;
            }
            catch (err) {
                deps_1.default.yubikey.disable();
                throw err;
            }
        }));
    }
    preauth(app, factor) {
        return this.put(`/apps/${app}/pre-authorizations`, {
            headers: { 'Heroku-Two-Factor-Code': factor },
        });
    }
    get(url, options = {}) {
        return this.http.get(url, options);
    }
    post(url, options = {}) {
        return this.http.post(url, options);
    }
    put(url, options = {}) {
        return this.http.put(url, options);
    }
    patch(url, options = {}) {
        return this.http.patch(url, options);
    }
    delete(url, options = {}) {
        return this.http.delete(url, options);
    }
    stream(url, options = {}) {
        return this.http.stream(url, options);
    }
    request(url, options = {}) {
        return this.http.request(url, options);
    }
    get defaultOptions() {
        return this.http.defaultOptions;
    }
}
exports.APIClient = APIClient;
