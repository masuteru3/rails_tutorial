"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@cli-engine/command");
const completions_1 = require("../completions");
const deps_1 = require("../deps");
const vars_1 = require("../vars");
class MultipleRemotesError extends Error {
    constructor(gitRemotes) {
        super(`Multiple apps in git remotes
  Usage: --remote ${gitRemotes[1].remote}
     or: --app ${gitRemotes[1].app}
  Your local git repository has more than 1 app referenced in git remotes.
  Because of this, we can't determine which app you want to run this command against.
  Specify the app you want with --app or --remote.
  Heroku remotes in repo:
  ${gitRemotes.map(r => `${r.app} (${r.remote})`).join('\n')}

  https://devcenter.heroku.com/articles/multiple-environments`);
    }
}
exports.AppCompletion = {
    cacheDuration: completions_1.oneDay,
    options: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let apps = yield completions_1.herokuGet('apps', ctx);
        return apps;
    }),
};
exports.app = command_1.flags.option({
    char: 'a',
    completion: exports.AppCompletion,
    description: 'app to run command against',
    default: ({ options, flags }) => {
        const envApp = process.env.HEROKU_APP;
        if (envApp)
            return envApp;
        let gitRemotes = getGitRemotes(flags.remote || configRemote());
        if (gitRemotes.length === 1)
            return gitRemotes[0].app;
        if (flags.remote && gitRemotes.length === 0) {
            throw new Error(`remote ${flags.remote} not found in git remotes`);
        }
        if (gitRemotes.length > 1 && options.required) {
            throw new MultipleRemotesError(gitRemotes);
        }
    },
});
exports.RemoteCompletion = {
    skipCache: true,
    options: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let remotes = getGitRemotes(configRemote());
        return remotes.map(r => r.remote);
    }),
};
exports.remote = command_1.flags.option({
    char: 'r',
    completion: exports.RemoteCompletion,
    description: 'git remote of app to use',
});
function configRemote() {
    let git = new deps_1.default.Git();
    try {
        return git.exec('config heroku.remote').trim();
    }
    catch (err) { }
}
function getGitRemotes(onlyRemote) {
    let git = new deps_1.default.Git();
    let appRemotes = [];
    let remotes;
    try {
        remotes = git.remotes;
    }
    catch (err) {
        return [];
    }
    for (let remote of remotes) {
        if (onlyRemote && remote.name !== onlyRemote)
            continue;
        for (let prefix of vars_1.vars.gitPrefixes) {
            const suffix = '.git';
            let match = remote.url.match(`${prefix}(.*)${suffix}`);
            if (!match)
                continue;
            appRemotes.push({
                app: match[1],
                remote: remote.name,
            });
        }
    }
    return appRemotes;
}
