"use strict";
/**
 * @module assync
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
function isPromiseInitFn(i) {
    return typeof i === 'function';
}
function isParallel(i) {
    return Array.isArray(i);
}
/**
 * @class Aasync
 * Main assync class
 *
 * @example
 * const {assync} = require('assync')
 *
 * async function main () {
 *   const output = await assync([1, null, 3]).filter(i => i !== null)
 *   console.dir(output)
 * }
 * main()
 */
class Assync extends Promise {
    constructor(input) {
        if (isPromiseInitFn(input)) {
            super(input);
            return this;
        }
        if (isParallel(input)) {
            let f = input;
            let promises = f.map(i => Promise.resolve(i));
            super((resolve, reject) => {
                Promise.resolve(Promise.all(promises))
                    .then(resolve)
                    .catch(reject);
            });
            this.parallel = promises;
        }
        else {
            super((resolve, reject) => {
                Promise.resolve(input || [])
                    .then(input => resolve(input || []))
                    .catch(reject);
            });
        }
    }
    compact() {
        return this.filter((i) => !!i);
    }
    filter(fn) {
        return new Assync(this.reduce((o, i) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (yield fn(i))
                o.push(i);
            return o;
        }), []));
    }
    flatMap(fn) {
        const p = this.reduce((o, i) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return fn ? o.concat(yield fn(i)) : o.concat(i);
        }), []);
        return new this.ctor(p);
    }
    /**
     * The reduce() method applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.
     *
     * @async
     * @param {Function} - function to call on each element
     * @returns {Promise}
     * @fulfil {any} - The result of the functions
     *
     *
     * @example
     * let input = assync([1, 2, 3, 4, 5])
     * let output = await input.reduce((o, i) => (o ? o + i : i), 0)
     * expect(output).toEqual(15)
     */
    reduce(fn, initial) {
        const p = this.then((input) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let agg = initial;
            for (let p of input) {
                let i = yield p;
                agg = yield fn(agg, yield i);
            }
            return agg;
        }));
        return p;
    }
    map(fn) {
        let p;
        if (this.parallel) {
            p = this.parallel.map(i => i.then(fn));
        }
        else {
            p = this.then(i => new Assync(i.map(fn)));
        }
        return new Assync(p);
    }
    get ctor() {
        return this.constructor;
    }
}
exports.Assync = Assync;
function assync(items) {
    return new Assync(items);
}
exports.default = assync;
exports.assync = assync;
