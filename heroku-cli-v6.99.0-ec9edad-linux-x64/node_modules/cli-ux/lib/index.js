"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const deps_1 = require("./deps");
// import { deprecate } from 'util'
const deprecate = process.env.DEBUG ? require('util').deprecate : (fn) => () => fn();
const deprecatedColor = deprecate(() => require('@heroku-cli/color').default, "cli.color is deprecated. Please use `import color from '@heroku-cli/color'` instead.");
class CLI extends deps_1.default.Base {
    get Prompt() {
        if (!this._prompt) {
            this._prompt = new deps_1.default.Prompt();
        }
        return this._prompt;
    }
    get Errors() {
        if (!this._errors) {
            this._errors = new deps_1.default.Errors();
        }
        return this._errors;
    }
    get action() {
        if (!this._action)
            this._action = deps_1.default.ActionBase.getSpinner();
        return this._action;
    }
    prompt(name, options = {}) {
        return this.action.pauseAsync(() => {
            return this.Prompt.prompt(name, options);
        }, deps_1.default.chalk.cyan('?'));
    }
    confirm(message) {
        return this.action.pauseAsync(() => __awaiter(this, void 0, void 0, function* () {
            const confirm = () => __awaiter(this, void 0, void 0, function* () {
                let response = (yield this.Prompt.prompt(message)).toLowerCase();
                if (['n', 'no'].includes(response))
                    return false;
                if (['y', 'yes'].includes(response))
                    return true;
                return confirm();
            });
            return confirm();
        }), deps_1.default.chalk.cyan('?'));
    }
    log(data, ...args) {
        this.action.pause(() => {
            return this.stdout.log(data, ...args);
        });
    }
    warn(err, options = {}) {
        this.emit('warn', typeof err === 'string' ? new Error(err) : err);
        this.action.pause(() => {
            return this.Errors.warn(err, options);
        }, deps_1.default.chalk.bold.yellow('!'));
    }
    error(err, options = {}) {
        this.emit('error', typeof err === 'string' ? new Error(err) : err);
        this.action.pause(() => {
            return this.Errors.error(err, options);
        }, deps_1.default.chalk.bold.red('!'));
    }
    exit(code = 1) {
        this.Errors.exit(code);
    }
    table(data, options) {
        let table = require('./table');
        return table(this, data, options);
    }
    styledJSON(obj) {
        let json = JSON.stringify(obj, null, 2);
        if (deps_1.default.chalk.enabled) {
            let cardinal = require('cardinal');
            let theme = require('cardinal/themes/jq');
            this.log(cardinal.highlight(json, { json: true, theme: theme }));
        }
        else {
            this.log(json);
        }
    }
    styledHeader(header) {
        this.log(deps_1.default.chalk.dim('=== ') + deps_1.default.chalk.bold(header));
    }
    styledObject(obj, keys) {
        const util = require('util');
        let keyLengths = Object.keys(obj).map(key => key.toString().length);
        let maxKeyLength = Math.max.apply(Math, keyLengths) + 2;
        function pp(obj) {
            if (typeof obj === 'string' || typeof obj === 'number') {
                return obj;
            }
            else if (typeof obj === 'object') {
                return Object.keys(obj)
                    .map(k => k + ': ' + util.inspect(obj[k]))
                    .join(', ');
            }
            else {
                return util.inspect(obj);
            }
        }
        let logKeyValue = (key, value) => {
            this.log(`${deps_1.default.chalk.blue(key)}:` + ' '.repeat(maxKeyLength - key.length - 1) + pp(value));
        };
        for (var key of keys || Object.keys(obj).sort()) {
            let value = obj[key];
            if (Array.isArray(value)) {
                if (value.length > 0) {
                    logKeyValue(key, value[0]);
                    for (var e of value.slice(1)) {
                        this.log(' '.repeat(maxKeyLength) + pp(e));
                    }
                }
            }
            else if (value !== null && value !== undefined) {
                logKeyValue(key, value);
            }
        }
    }
    get color() {
        return deprecatedColor();
    }
    /**
     * puts in a handler for process.on('uncaughtException') and process.on('unhandledRejection')
     */
    handleUnhandleds() {
        this.Errors.handleUnhandleds();
    }
    /**
     * cleanup any outstanding output like actions that need to be stopped
     */
    done() {
        this.action.stop();
    }
}
exports.CLI = CLI;
exports.cli = new CLI();
exports.default = exports.cli;
// swallow error event so it does not cause a crash
exports.cli.on('error', () => { });
