"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_ux_1 = require("cli-ux");
const path = require("path");
const deps_1 = require("../deps");
const debug = require('debug')('cli:yarn');
class Yarn {
    constructor({ config, cwd }) {
        this.config = config;
        this.cwd = cwd;
    }
    get bin() {
        return require.resolve('yarn/bin/yarn.js');
    }
    // https://github.com/yarnpkg/yarn/blob/master/src/constants.js#L73-L90
    pathKey(env = process.env) {
        let pathKey = 'PATH';
        // windows calls its path "Path" usually, but this is not guaranteed.
        if (this.config.windows) {
            pathKey = 'Path';
            for (const key in env) {
                if (key.toLowerCase() === 'path') {
                    pathKey = key;
                }
            }
        }
        return pathKey;
    }
    // https://github.com/yarnpkg/yarn/blob/master/src/util/execute-lifecycle-script.js#L130-L154
    env() {
        let pathKey = this.pathKey();
        const pathParts = (process.env[pathKey] || '').split(path.delimiter);
        pathParts.unshift(path.dirname(process.execPath));
        return Object.assign({}, process.env, { [pathKey]: pathParts.join(path.delimiter) });
    }
    fork(modulePath, args = [], options = {}) {
        return new Promise((resolve, reject) => {
            const { fork } = require('child_process');
            let forked = fork(modulePath, args, options);
            let stdout = '';
            let stderr = '';
            forked.stdout.setEncoding('utf8');
            forked.stdout.on('data', (data) => {
                if (this.config.debug) {
                    cli_ux_1.default.stdout.write(data);
                }
                stdout += data;
            });
            forked.stderr.setEncoding('utf8');
            forked.stderr.on('data', (data) => {
                if (this.config.debug) {
                    cli_ux_1.default.stderr.write(data);
                }
                stderr += data;
            });
            forked.on('error', reject);
            forked.on('exit', (code) => {
                if (code === 0) {
                    resolve();
                }
                else {
                    reject(new Error(`yarn ${args.join(' ')} exited with code ${code}\n${stderr}\n${stdout}`));
                }
            });
            // Fix windows bug with node-gyp hanging for input forever
            if (this.config.windows) {
                forked.stdin.write('\n');
            }
        });
    }
    exec(args = []) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (args.length !== 0)
                yield this.checkForYarnLock();
            if (args[0] !== 'run') {
                const cacheDir = path.join(this.config.cacheDir, 'yarn');
                args = [
                    ...args,
                    '--non-interactive',
                    `--mutex=file:${path.join(this.cwd, 'yarn.lock')}`,
                    `--preferred-cache-folder=${cacheDir}`,
                    ...this.proxyArgs(),
                ];
                if (this.config.npmRegistry) {
                    args.push(`--registry=${this.config.npmRegistry}`);
                }
            }
            let options = {
                cwd: this.cwd,
                stdio: [null, null, null, 'ipc'],
                env: this.env(),
            };
            debug(`${this.cwd}: ${this.bin} ${args.join(' ')}`);
            try {
                yield this.fork(this.bin, args, options);
                debug('done');
            }
            catch (err) {
                // TODO: https://github.com/yarnpkg/yarn/issues/2191
                let networkConcurrency = '--network-concurrency=1';
                if (err.message.includes('EAI_AGAIN') && !args.includes(networkConcurrency)) {
                    debug('EAI_AGAIN');
                    return this.exec([...args, networkConcurrency]);
                }
                else
                    throw err;
            }
        });
    }
    checkForYarnLock() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // add yarn lockfile if it does not exist
            if (this.cwd && !(yield deps_1.default.file.exists(path.join(this.cwd, 'yarn.lock')))) {
                yield this.exec();
            }
        });
    }
    proxyArgs() {
        let args = [];
        let http = process.env.http_proxy || process.env.HTTP_PROXY;
        let https = process.env.https_proxy || process.env.HTTPS_PROXY;
        if (http)
            args.push(`--proxy=${http}`);
        if (https)
            args.push(`--https-proxy=${https}`);
        return args;
    }
}
exports.default = Yarn;
