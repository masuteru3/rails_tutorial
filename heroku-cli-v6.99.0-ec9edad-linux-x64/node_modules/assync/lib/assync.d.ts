/**
 * @module assync
 */
export declare type Falsy = '' | 0 | false | null | undefined;
export declare type MaybePromise<T> = T | PromiseLike<T>;
export declare type ReduceFn<T, TResult> = (prev: TResult, i: T) => MaybePromise<TResult>;
export declare type PromiseInitFn<T> = () => {
    resolve: (value?: T | PromiseLike<T>) => void;
    reject: (reason?: any) => void;
};
export declare type AssyncConstructorInput<T> = PromiseInitFn<T[]> | MaybePromise<T[]> | MaybePromise<T>[];
/**
 * @class Aasync
 * Main assync class
 *
 * @example
 * const {assync} = require('assync')
 *
 * async function main () {
 *   const output = await assync([1, null, 3]).filter(i => i !== null)
 *   console.dir(output)
 * }
 * main()
 */
export declare class Assync<T> extends Promise<T[]> {
    private parallel?;
    constructor(input: AssyncConstructorInput<T>);
    compact<U>(this: Assync<U | Falsy>): Assync<U>;
    filter<U extends T>(fn: (i: T) => i is U): Assync<U>;
    filter(fn: (i: T) => MaybePromise<boolean>): Assync<T>;
    flatMap<U>(fn: (i: T) => U[]): Assync<U>;
    flatMap<U>(this: Assync<U[]>): Assync<U>;
    /**
     * The reduce() method applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.
     *
     * @async
     * @param {Function} - function to call on each element
     * @returns {Promise}
     * @fulfil {any} - The result of the functions
     *
     *
     * @example
     * let input = assync([1, 2, 3, 4, 5])
     * let output = await input.reduce((o, i) => (o ? o + i : i), 0)
     * expect(output).toEqual(15)
     */
    reduce<U>(fn: ReduceFn<T, U>, initial: U): Promise<U>;
    map<U>(fn: (i: T) => MaybePromise<U>): Assync<U>;
    private readonly ctor;
}
export default function assync<T>(items: MaybePromise<T[]>): Assync<T>;
export { assync };
