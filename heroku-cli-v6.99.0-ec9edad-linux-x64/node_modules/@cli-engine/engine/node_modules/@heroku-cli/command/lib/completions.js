"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const deps_1 = require("./deps");
var app_1 = require("./flags/app");
exports.AppCompletion = app_1.AppCompletion;
exports.RemoteCompletion = app_1.RemoteCompletion;
exports.oneDay = 60 * 60 * 24;
exports.herokuGet = (resource, ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
    const heroku = new deps_1.default.APIClient(ctx.config);
    let { body: resources } = yield heroku.get(`/${resource}`);
    if (typeof resources === 'string')
        resources = JSON.parse(resources);
    return resources.map((a) => a.name).sort();
});
exports.BuildpackCompletion = {
    skipCache: true,
    options: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return [
            'heroku/ruby',
            'heroku/nodejs',
            'heroku/clojure',
            'heroku/python',
            'heroku/java',
            'heroku/gradle',
            'heroku/scala',
            'heroku/php',
            'heroku/go',
        ];
    }),
};
exports.AppAddonCompletion = {
    cacheDuration: exports.oneDay,
    cacheKey: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return ctx.flags && ctx.flags.app ? `${ctx.flags.app}_addons` : '';
    }),
    options: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const heroku = new deps_1.default.APIClient(ctx.config);
        let addons = ctx.flags && ctx.flags.app ? yield heroku.get(`/apps/${ctx.flags.app}/addons`) : [];
        return addons.map((a) => a.name).sort();
    }),
};
exports.AppDynoCompletion = {
    cacheDuration: exports.oneDay,
    cacheKey: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return ctx.flags && ctx.flags.app ? `${ctx.flags.app}_dynos` : '';
    }),
    options: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const heroku = new deps_1.default.APIClient(ctx.config);
        let dynos = ctx.flags && ctx.flags.app ? yield heroku.get(`/apps/${ctx.flags.app}/dynos`) : [];
        return dynos.map((a) => a.type).sort();
    }),
};
exports.DynoSizeCompletion = {
    cacheDuration: exports.oneDay * 90,
    options: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let sizes = yield exports.herokuGet('dyno-sizes', ctx);
        return sizes;
    }),
};
exports.FileCompletion = {
    skipCache: true,
    options: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let files = yield deps_1.default.file.readdir(process.cwd());
        return files;
    }),
};
exports.PipelineCompletion = {
    cacheDuration: exports.oneDay,
    options: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let pipelines = yield exports.herokuGet('pipelines', ctx);
        return pipelines;
    }),
};
exports.ProcessTypeCompletion = {
    skipCache: true,
    options: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let types = [];
        let procfile = path.join(process.cwd(), 'Procfile');
        try {
            let buff = yield deps_1.default.file.readFile(procfile);
            types = buff
                .toString()
                .split('\n')
                .map(s => {
                if (!s)
                    return false;
                let m = s.match(/^([A-Za-z0-9_-]+)/);
                return m ? m[0] : false;
            })
                .filter(t => t);
        }
        catch (err) {
            if (err.code !== 'ENOENT')
                throw err;
        }
        return types;
    }),
};
exports.RegionCompletion = {
    cacheDuration: exports.oneDay * 7,
    options: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let regions = yield exports.herokuGet('regions', ctx);
        return regions;
    }),
};
exports.RoleCompletion = {
    skipCache: true,
    options: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return ['admin', 'collaborator', 'member', 'owner'];
    }),
};
exports.ScopeCompletion = {
    skipCache: true,
    options: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return ['global', 'identity', 'read', 'write', 'read-protected', 'write-protected'];
    }),
};
exports.SpaceCompletion = {
    cacheDuration: exports.oneDay,
    options: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let spaces = yield exports.herokuGet('spaces', ctx);
        return spaces;
    }),
};
exports.StackCompletion = {
    cacheDuration: exports.oneDay,
    options: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let stacks = yield exports.herokuGet('stacks', ctx);
        return stacks;
    }),
};
exports.StageCompletion = {
    skipCache: true,
    options: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return ['test', 'review', 'development', 'staging', 'production'];
    }),
};
exports.TeamCompletion = {
    cacheDuration: exports.oneDay,
    options: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let teams = yield exports.herokuGet('teams', ctx);
        return teams;
    }),
};
