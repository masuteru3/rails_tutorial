"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function topicOf(id) {
    if (!id)
        return '';
    return id
        .split(':')
        .slice(0, -1)
        .join(':');
}
function keyOf(id) {
    if (!id)
        return '';
    return id
        .split(':')
        .slice(-1)
        .join(':');
}
class TopicBase {
    constructor() {
        this.subtopics = {};
        this.commands = {};
    }
    findTopic(id) {
        let key = keyOf(id);
        let parentID = topicOf(id);
        if (parentID) {
            let parent = this.findTopic(parentID);
            return parent && parent.subtopics[key];
        }
        return this.subtopics[key];
    }
    findCommand(id) {
        const topic = this.findTopic(topicOf(id));
        if (topic)
            return topic.findCommand(id);
        return this.commands[keyOf(id)];
    }
}
exports.TopicBase = TopicBase;
class Topic extends TopicBase {
    constructor(opts) {
        super();
        this.name = opts.name;
        this.description = opts.description;
        this.hidden = !!opts.hidden;
        this.commands = opts.commands || {};
    }
}
exports.Topic = Topic;
function topicsToArray(input, base) {
    if (!input)
        return [];
    if (Array.isArray(input))
        return input;
    base = base ? `${base}:` : '';
    return Object.keys(input).map(k => new Topic(Object.assign({}, input[k], { name: `${base}${k}` })));
}
exports.topicsToArray = topicsToArray;
function commandsToArray(input, base) {
    if (!input)
        return [];
    if (Array.isArray(input))
        return input;
    base = base ? `${base}:` : '';
    return Object.keys(input).map(k => input[k]);
}
exports.commandsToArray = commandsToArray;
class RootTopic extends TopicBase {
    constructor() {
        super(...arguments);
        this.subtopics = {};
        this.commands = {};
        this.allCommands = [];
        this.allTopics = [];
    }
    findCommand(id) {
        for (let c of this.allCommands) {
            if (c.aliases.find(a => a === id))
                return c;
        }
        return super.findCommand(id);
    }
    addTopics(topics) {
        for (let t of topicsToArray(topics)) {
            if (!t.name)
                continue;
            let topic = this.findOrCreateTopic(t.name);
            this.mergeTopics(topic, t);
            this.addTopics(topicsToArray(t.subtopics, t.name));
            this.addCommands(commandsToArray(t.commands, t.name));
        }
    }
    addCommands(commands) {
        if (!commands)
            return;
        for (const c of commands) {
            this.allCommands.push(c);
            let topicID = topicOf(c.id);
            let topic = topicID ? this.findOrCreateTopic(topicID) : this;
            topic.commands[keyOf(c.id)] = c;
        }
    }
    findOrCreateTopic(name) {
        let key = keyOf(name);
        let parentID = topicOf(name);
        let topic = this;
        if (parentID) {
            let parent = this.findOrCreateTopic(parentID);
            topic = parent;
        }
        let topics = topic.subtopics;
        if (!topics[key]) {
            topics[key] = new Topic({ name });
            this.allTopics.push(topics[key]);
        }
        return topics[key];
    }
    mergeTopics(a, b) {
        a.description = b.description || a.description;
        a.hidden = b.hidden || a.hidden;
    }
}
exports.RootTopic = RootTopic;
