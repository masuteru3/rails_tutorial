"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require('./fs');
const color_1 = require("@heroku-cli/color");
const cli_ux_1 = require("cli-ux");
const path = require("path");
const config_1 = require("./config");
const deps_1 = require("./deps");
class CLI {
    constructor(config) {
        this.config = config;
    }
    run(argv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.debug('starting run: %o', argv);
            this.setupHandlers();
            const id = argv[2];
            if (id !== 'update') {
                const updater = new deps_1.default.Updater(this.config);
                yield updater.autoupdate();
            }
            const commands = new deps_1.default.CommandManager(this.config);
            const result = yield commands.run(argv);
            yield this.exitAfterStdoutFlush();
            return result;
        });
    }
    get debug() {
        return require('debug')('cli');
    }
    get global() {
        return global;
    }
    setupHandlers() {
        process.env.CLI_ENGINE_VERSION = require('../package.json').version;
        if (this.global.testing)
            return;
        process.once('SIGINT', () => {
            if (cli_ux_1.default.action.task)
                cli_ux_1.default.action.stop(color_1.color.red('ctrl-c'));
            cli_ux_1.default.exit(1);
        });
        let handleErr = (err) => {
            cli_ux_1.default.error(err);
        };
        process.once('uncaughtException', handleErr);
        process.once('unhandledRejection', handleErr);
        const handleEPIPE = (err) => {
            if (err.code !== 'EPIPE')
                throw err;
        };
        process.stdout.on('error', handleEPIPE);
        process.stderr.on('error', handleEPIPE);
    }
    exitAfterStdoutFlush() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.global.testing)
                return;
            yield deps_1.default.util.timeout(this.flush(), 10000);
        });
    }
    flush() {
        let p = new Promise(resolve => process.stdout.once('drain', resolve));
        process.stdout.write('');
        return p;
    }
}
exports.default = CLI;
function run(arg1 = process.argv, opts = {}) {
    let argv;
    if (Array.isArray(arg1))
        argv = arg1;
    else {
        opts = arg1;
        argv = opts.argv || process.argv;
    }
    if (!opts.root)
        opts.root = path.join(module.parent.filename, '..', '..');
    if (!opts.pjson) {
        const f = path.join(opts.root, 'package.json');
        opts.pjson = require(f);
        deps_1.default.validate.cliPjson(opts.pjson, f);
    }
    const config = new config_1.Config(opts);
    config.plugins = new deps_1.default.Plugins(config);
    if (config.debug)
        cli_ux_1.default.config.debug = true;
    cli_ux_1.default.config.errlog = config.errlog;
    return new CLI(config).run(argv);
}
exports.run = run;
var hooks_1 = require("./hooks");
exports.Hook = hooks_1.Hook;
