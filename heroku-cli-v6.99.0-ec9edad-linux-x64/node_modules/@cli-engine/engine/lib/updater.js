"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_ux_1 = require("cli-ux");
const path = require("path");
const rwlockfile_1 = require("rwlockfile");
const ts_lodash_1 = require("ts-lodash");
const deps_1 = require("./deps");
const { spawn } = require('cross-spawn');
const debug = require('debug')('cli:updater');
function mtime(f) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { mtime } = yield deps_1.default.file.stat(f);
        return deps_1.default.moment(mtime);
    });
}
function timestamp(msg) {
    return `[${deps_1.default.moment().format()}] ${msg}`;
}
class Updater {
    constructor(config) {
        this.config = config;
        this.http = deps_1.default.HTTP.defaults({ headers: { 'user-agent': config.userAgent } });
    }
    get autoupdatefile() {
        return path.join(this.config.cacheDir, 'autoupdate');
    }
    get autoupdatelogfile() {
        return path.join(this.config.cacheDir, 'autoupdate.log');
    }
    get versionFile() {
        return path.join(this.config.cacheDir, `${this.config.channel}.version`);
    }
    get clientRoot() {
        return path.join(this.config.dataDir, 'client');
    }
    get clientBin() {
        let b = path.join(this.clientRoot, 'bin', this.config.bin);
        return this.config.windows ? `${b}.cmd` : b;
    }
    get binPath() {
        return this.config.reexecBin || this.config.bin;
    }
    get s3Host() {
        return this.config.s3 && this.config.s3.host;
    }
    s3url(channel, p) {
        if (!this.s3Host)
            throw new Error('S3 host not defined');
        return `https://${this.s3Host}/${this.config.name}/channels/${channel}/${p}`;
    }
    fetchManifest(channel, oclif) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                let url = this.s3url(channel, `${this.config.platform}-${this.config.arch}`);
                if (oclif) {
                    url = `https://${this.s3Host}/${this.config.platform}-${this.config.arch}`;
                }
                let { body } = yield this.http.get(url);
                return body;
            }
            catch (err) {
                if (err.statusCode === 403)
                    throw new Error(`HTTP 403: Invalid channel ${channel}`);
                throw err;
            }
        });
    }
    fetchVersion(download) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let v;
            try {
                if (!download)
                    v = yield deps_1.default.file.readJSON(this.versionFile);
            }
            catch (err) {
                if (err.code !== 'ENOENT')
                    throw err;
            }
            if (!v) {
                debug('fetching latest %s version', this.config.channel);
                let { body } = yield this.http.get(this.s3url(this.config.channel, 'version'));
                v = body;
                yield this._catch(() => deps_1.default.file.outputJSON(this.versionFile, v));
            }
            return v;
        });
    }
    warnIfUpdateAvailable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this._catch(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.s3Host)
                    return;
                let v = yield this.fetchVersion(false);
                if (deps_1.default.util.minorVersionGreater(this.config.version, v.version)) {
                    cli_ux_1.cli.warn(`${this.config.name}: update available from ${this.config.version} to ${v.version}`);
                }
                if (v.message) {
                    cli_ux_1.cli.warn(`${this.config.name}: ${v.message}`);
                }
            }));
        });
    }
    autoupdate(force = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const clientDir = path.join(this.clientRoot, this.config.version);
                if (yield deps_1.default.file.exists(clientDir)) {
                    yield deps_1.default.file.touch(clientDir);
                }
                yield this.warnIfUpdateAvailable();
                if (!force && !(yield this.autoupdateNeeded()))
                    return;
                debug('autoupdate running');
                debug(`spawning autoupdate on ${this.binPath}`);
                let fd = yield deps_1.default.file.open(this.autoupdatelogfile, 'a');
                deps_1.default.file.write(fd, timestamp(`starting \`${this.binPath} update --autoupdate\` from ${process.argv.slice(1, 3).join(' ')}\n`));
                spawn(this.binPath, ['update', '--autoupdate'], {
                    detached: !this.config.windows,
                    stdio: ['ignore', fd, fd],
                    env: this.autoupdateEnv,
                })
                    .on('error', (e) => cli_ux_1.cli.warn(e, { context: 'autoupdate:' }))
                    .unref();
            }
            catch (e) {
                cli_ux_1.cli.warn(e, { context: 'autoupdate:' });
            }
            finally {
                yield deps_1.default.file.touch(this.autoupdatefile);
            }
        });
    }
    update(manifest, oclif) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.s3Host)
                throw new Error('S3 host not defined');
            const base = this.base(manifest);
            const output = path.join(this.clientRoot, manifest.version);
            let tmp = path.join(this.clientRoot, base);
            const lock = new rwlockfile_1.default(this.autoupdatefile, { ifLocked: () => cli_ux_1.cli.action.start('CLI is updating') });
            let url = `https://${this.s3Host}/${this.config.name}/channels/${manifest.channel}/${base}.tar.gz`;
            if (oclif) {
                tmp = path.join(this.clientRoot, this.config.bin);
                url = manifest.gz;
            }
            yield lock.add('write', { reason: 'update' });
            try {
                let { response: stream } = yield this.http.stream(url);
                yield deps_1.default.file.emptyDir(tmp);
                let extraction = this.extract(stream, this.clientRoot, manifest.sha256gz);
                // TODO: use cli.action.type
                if (deps_1.default.filesize && cli_ux_1.cli.action.frames) {
                    // if spinner action
                    let total = stream.headers['content-length'];
                    let current = 0;
                    const updateStatus = ts_lodash_1.default.throttle((newStatus) => {
                        cli_ux_1.cli.action.status = newStatus;
                    }, 500, { leading: true, trailing: false });
                    stream.on('data', data => {
                        current += data.length;
                        updateStatus(`${deps_1.default.filesize(current)}/${deps_1.default.filesize(total)}`);
                    });
                }
                yield extraction;
                if (yield deps_1.default.file.exists(output)) {
                    const old = `${output}.old`;
                    yield deps_1.default.file.remove(old);
                    yield deps_1.default.file.rename(output, old);
                }
                yield deps_1.default.file.rename(tmp, output);
                yield deps_1.default.file.touch(output);
                yield this._createBin(manifest);
            }
            finally {
                yield lock.remove('write');
            }
            yield this.reexecUpdate();
        });
    }
    tidy() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.config.reexecBin)
                    return;
                if (!this.config.reexecBin.includes(this.config.version))
                    return;
                const { moment, file } = deps_1.default;
                let root = this.clientRoot;
                if (!(yield file.exists(root)))
                    return;
                let files = yield file.ls(root);
                let promises = files.map((f) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (['bin', this.config.version].includes(path.basename(f.path)))
                        return;
                    if (moment(f.stat.mtime).isBefore(moment().subtract(7, 'days'))) {
                        yield file.remove(f.path);
                    }
                }));
                for (let p of promises)
                    yield p;
            }
            catch (err) {
                cli_ux_1.cli.warn(err);
            }
        });
    }
    extract(stream, dir, sha) {
        const zlib = require('zlib');
        const tar = require('tar-fs');
        const crypto = require('crypto');
        return new Promise((resolve, reject) => {
            let shaValidated = false;
            let extracted = false;
            let check = () => {
                if (shaValidated && extracted) {
                    resolve();
                }
            };
            let fail = (err) => {
                deps_1.default.file.remove(dir).then(() => reject(err));
            };
            let hasher = crypto.createHash('sha256');
            stream.on('error', fail);
            stream.on('data', d => hasher.update(d));
            stream.on('end', () => {
                let shasum = hasher.digest('hex');
                if (sha === shasum) {
                    shaValidated = true;
                    check();
                }
                else {
                    reject(new Error(`SHA mismatch: expected ${shasum} to be ${sha}`));
                }
            });
            let ignore = (_, header) => {
                switch (header.type) {
                    case 'directory':
                    case 'file':
                        if (process.env.CLI_ENGINE_DEBUG_UPDATE_FILES)
                            debug(header.name);
                        return false;
                    case 'symlink':
                        return true;
                    default:
                        throw new Error(header.type);
                }
            };
            let extract = tar.extract(dir, { ignore });
            extract.on('error', fail);
            extract.on('finish', () => {
                extracted = true;
                check();
            });
            let gunzip = zlib.createGunzip();
            gunzip.on('error', fail);
            stream.pipe(gunzip).pipe(extract);
        });
    }
    base(manifest) {
        return `${this.config.name}-v${manifest.version}-${this.config.platform}-${this.config.arch}`;
    }
    autoupdateNeeded() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const m = yield mtime(this.autoupdatefile);
                return m.isBefore(deps_1.default.moment().subtract(5, 'hours'));
            }
            catch (err) {
                if (err.code !== 'ENOENT')
                    cli_ux_1.cli.error(err.stack);
                if (global.testing)
                    return false;
                debug('autoupdate ENOENT');
                return true;
            }
        });
    }
    get timestampEnvVar() {
        // TODO: use function from @cli-engine/config
        let bin = this.config.bin.replace('-', '_').toUpperCase();
        return `${bin}_TIMESTAMPS`;
    }
    get skipAnalyticsEnvVar() {
        let bin = this.config.bin.replace('-', '_').toUpperCase();
        return `${bin}_SKIP_ANALYTICS`;
    }
    get autoupdateEnv() {
        return Object.assign({}, process.env, {
            [this.timestampEnvVar]: '1',
            [this.skipAnalyticsEnvVar]: '1',
        });
    }
    reexecUpdate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            cli_ux_1.cli.action.stop();
            return new Promise((_, reject) => {
                debug('restarting CLI after update', this.clientBin);
                spawn(this.clientBin, ['update'], {
                    stdio: 'inherit',
                    env: Object.assign({}, process.env, { CLI_ENGINE_HIDE_UPDATED_MESSAGE: '1' }),
                })
                    .on('error', reject)
                    .on('close', (status) => {
                    try {
                        cli_ux_1.cli.exit(status);
                    }
                    catch (err) {
                        reject(err);
                    }
                });
            });
        });
    }
    _createBin(manifest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let dst = this.clientBin;
            if (this.config.windows) {
                let body = `@echo off
"%~dp0\\..\\${manifest.version}\\bin\\${this.config.bin}.cmd" %*
`;
                yield deps_1.default.file.outputFile(dst, body);
            }
            else {
                let body = `#!/usr/bin/env bash
set -e
get_script_dir () {
  SOURCE="\${BASH_SOURCE[0]}"
  # While $SOURCE is a symlink, resolve it
  while [ -h "$SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    SOURCE="$( readlink "$SOURCE" )"
    # If $SOURCE was a relative symlink (so no "/" as prefix, need to resolve it relative to the symlink base directory
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  echo "$DIR"
}
DIR=$(get_script_dir)
HEROKU_CLI_REDIRECTED=1 "$DIR/../${manifest.version}/bin/${this.config.bin}" "$@"
`;
                yield deps_1.default.file.remove(dst);
                yield deps_1.default.file.outputFile(dst, body);
                yield deps_1.default.fs.chmod(dst, 0o755);
            }
        });
    }
    _catch(fn) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield Promise.resolve(fn());
            }
            catch (err) {
                debug(err);
            }
        });
    }
}
exports.Updater = Updater;
