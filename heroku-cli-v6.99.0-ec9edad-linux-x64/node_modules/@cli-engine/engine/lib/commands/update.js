"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@cli-engine/command");
const color_1 = require("@heroku-cli/color");
const cli_ux_1 = require("cli-ux");
const path = require("path");
const deps_1 = require("../deps");
const hooks_1 = require("../hooks");
const updater_1 = require("../updater");
const util_1 = require("../util");
const base_1 = require("./base");
const update_1 = require("./plugins/update");
const debug = require('debug')('cli:update');
const g = global;
const cliBin = g.config ? g.config.bin : 'heroku';
class Update extends base_1.default {
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.updater = new updater_1.Updater(this.config);
            if (this.flags.autoupdate)
                yield this.debounce();
            else {
                // on manual run, also log to file
                cli_ux_1.default.config.errlog = path.join(this.config.cacheDir, 'autoupdate');
            }
            if (this.config.updateDisabled) {
                cli_ux_1.default.warn(this.config.updateDisabled);
            }
            else {
                cli_ux_1.default.action.start(`${this.config.name}: Updating CLI`);
                let channel = this.argv[0] || this.config.channel;
                const oclif = channel === 'oclif' || channel === 'beta' || this.updateToOclif();
                let manifest = yield this.updater.fetchManifest(channel, oclif);
                if (this.config.version === manifest.version && channel === this.config.channel) {
                    if (!process.env.CLI_ENGINE_HIDE_UPDATED_MESSAGE) {
                        cli_ux_1.default.action.stop(`already on latest version: ${this.config.version}`);
                    }
                }
                else {
                    cli_ux_1.default.action.start(`${this.config.name}: Updating CLI from ${color_1.color.green(this.config.version)} to ${color_1.color.green(manifest.version)}${channel === 'stable' ? '' : ' (' + color_1.color.yellow(channel) + ')'}`);
                    yield this.updater.update(manifest, oclif);
                }
            }
            debug('fetch version');
            yield this.updater.fetchVersion(true);
            debug('plugins update');
            yield update_1.default.run([], this.config);
            debug('log chop');
            yield this.logChop();
            debug('tidy');
            yield this.updater.tidy();
            const hooks = new hooks_1.Hooks(this.config);
            yield hooks.run('update');
            debug('done');
            cli_ux_1.default.action.stop();
        });
    }
    logChop() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const logChopper = require('log-chopper').default;
                yield logChopper.chop(this.config.errlog);
            }
            catch (e) {
                debug(e.message);
            }
        });
    }
    mtime(f) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { mtime } = yield deps_1.default.file.stat(f);
            return deps_1.default.moment(mtime);
        });
    }
    updateToOclif() {
        try {
            const rollout = parseInt(this.config.pjson.oclif.update.autoupdate.rollout, 10);
            if (!rollout)
                return false;
            const chance = Math.random() * 100;
            debug({ oclif_rollout: { chance, rollout } });
            return chance > rollout;
        }
        catch (err) {
            cli_ux_1.default.warn(err);
        }
        return false;
    }
    debounce() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const m = yield this.mtime(this.updater.autoupdatefile);
            const waitUntil = m.add(1, 'hour');
            if (waitUntil.isAfter(deps_1.default.moment())) {
                yield cli_ux_1.default.log(`waiting until ${waitUntil.toISOString()} to update`);
                yield util_1.wait(60 * 1000); // wait 1 minute
                return this.debounce();
            }
            cli_ux_1.default.log(`time to update`);
        });
    }
}
Update.topic = 'update';
Update.description = `update the ${cliBin} CLI`;
Update.args = [{ name: 'channel', optional: true }];
Update.flags = {
    autoupdate: command_1.flags.boolean({ hidden: true }),
};
exports.default = Update;
