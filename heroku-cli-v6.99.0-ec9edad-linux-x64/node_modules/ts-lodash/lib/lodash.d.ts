/// <reference types="lodash" />
import lodash = require('lodash');
declare const _default: {
    readonly add: (augend: number, addend: number) => number;
    readonly after: <TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc;
    readonly ary: (func: (...args: any[]) => any, n?: number | undefined) => (...args: any[]) => any;
    readonly assignWith: {
        <TObject, TSource>(object: TObject, source: TSource, customizer: lodash.AssignCustomizer): TObject & TSource;
        <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: lodash.AssignCustomizer): TObject & TSource1 & TSource2;
        <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: lodash.AssignCustomizer): TObject & TSource1 & TSource2 & TSource3;
        <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: lodash.AssignCustomizer): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        <TObject>(object: TObject): TObject;
        <TResult>(object: any, ...otherArgs: any[]): TResult;
    };
    readonly at: {
        <T>(object: ArrayLike<T> | lodash.Dictionary<T> | null | undefined, ...props: lodash.Many<PropertyKey>[]): T[];
        <T extends object>(object: T | null | undefined, ...props: lodash.Many<keyof T>[]): T[keyof T][];
    };
    readonly attempt: <TResult>(func: (...args: any[]) => TResult, ...args: any[]) => Error | TResult;
    readonly before: <TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc;
    readonly bindKey: lodash.FunctionBindKey;
    readonly camelCase: (string?: string | undefined) => string;
    readonly capitalize: (string?: string | undefined) => string;
    readonly castArray: <T>(value?: T | T[] | undefined) => T[];
    readonly ceil: (n: number, precision?: number | undefined) => number;
    readonly chunk: <T>(array: ArrayLike<T> | null | undefined, size?: number | undefined) => T[][];
    readonly clamp: {
        (number: number, lower: number, upper: number): number;
        (number: number, upper: number): number;
    };
    readonly clone: <T>(value: T) => T;
    readonly cloneDeep: <T>(value: T) => T;
    readonly cloneDeepWith: {
        <T>(value: T, customizer: lodash.CloneDeepWithCustomizer<T>): any;
        <T>(value: T): T;
    };
    readonly cloneWith: {
        <T, TResult extends string | number | boolean | object | null>(value: T, customizer: lodash.CloneWithCustomizer<T, TResult>): TResult;
        <T, TResult>(value: T, customizer: lodash.CloneWithCustomizer<T, TResult | undefined>): T | TResult;
        <T>(value: T): T;
    };
    readonly compact: <T>(array: ArrayLike<false | "" | 0 | T | null | undefined> | null | undefined) => T[];
    readonly cond: <T, R>(pairs: [(val: T) => boolean, (val: T) => R][]) => (Target: T) => R;
    readonly conforms: <T>(source: lodash.ConformsPredicateObject<T>) => (value: T) => boolean;
    readonly conformsTo: <T>(object: T, source: lodash.ConformsPredicateObject<T>) => boolean;
    readonly countBy: {
        <T>(collection: string | null | undefined, iteratee?: lodash.StringIterator<T> | undefined): lodash.Dictionary<number>;
        <T>(collection: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined): lodash.Dictionary<number>;
        <T>(collection: lodash.NumericDictionary<T> | null | undefined, iteratee?: string | [string, any] | lodash.NumericDictionaryIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined): lodash.Dictionary<number>;
        <T extends object>(collection: T | null | undefined, iteratee?: string | [string, any] | lodash.ObjectIterator<T, lodash.NotVoid> | lodash.PartialDeep<T[keyof T]> | undefined): lodash.Dictionary<number>;
    };
    readonly create: <T extends object, U extends object>(prototype: T, properties?: U | undefined) => T & U;
    readonly curry: {
        <T1, R>(func: (t1: T1) => R, arity?: number | undefined): lodash.CurriedFunction1<T1, R>;
        <T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number | undefined): lodash.CurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number | undefined): lodash.CurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number | undefined): lodash.CurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number | undefined): lodash.CurriedFunction5<T1, T2, T3, T4, T5, R>;
        (func: (...args: any[]) => any, arity?: number | undefined): (...args: any[]) => any;
    };
    readonly curryRight: {
        <T1, R>(func: (t1: T1) => R, arity?: number | undefined): lodash.RightCurriedFunction1<T1, R>;
        <T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number | undefined): lodash.RightCurriedFunction2<T1, T2, R>;
        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number | undefined): lodash.RightCurriedFunction3<T1, T2, T3, R>;
        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number | undefined): lodash.RightCurriedFunction4<T1, T2, T3, T4, R>;
        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number | undefined): lodash.RightCurriedFunction5<T1, T2, T3, T4, T5, R>;
        (func: (...args: any[]) => any, arity?: number | undefined): (...args: any[]) => any;
    };
    readonly debounce: <T extends (...args: any[]) => any>(func: T, wait?: number | undefined, options?: lodash.DebounceSettings | undefined) => T & lodash.Cancelable;
    readonly deburr: (string?: string | undefined) => string;
    readonly defaultTo: {
        <T>(value: T | null | undefined, defaultValue: T): T;
        <T, TDefault>(value: T | null | undefined, defaultValue: TDefault): T | TDefault;
    };
    readonly defaults: {
        <TObject, TSource>(object: TObject, source: TSource): TSource & TObject;
        <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TSource2 & TSource1 & TObject;
        <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TSource3 & TSource2 & TSource1 & TObject;
        <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TSource4 & TSource3 & TSource2 & TSource1 & TObject;
        <TObject>(object: TObject): TObject;
        (object: any, ...sources: any[]): any;
    };
    readonly defaultsDeep: (object: any, ...sources: any[]) => any;
    readonly defer: (func: (...args: any[]) => any, ...args: any[]) => number;
    readonly delay: (func: (...args: any[]) => any, wait: number, ...args: any[]) => number;
    readonly difference: <T>(array: ArrayLike<T> | null | undefined, ...values: ArrayLike<T>[]) => T[];
    readonly differenceBy: {
        <T1, T2>(array: ArrayLike<T1> | null | undefined, values: ArrayLike<T2>, iteratee: lodash.ValueIteratee<T1 | T2>): T1[];
        <T1, T2, T3>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, iteratee: lodash.ValueIteratee<T1 | T2 | T3>): T1[];
        <T1, T2, T3, T4>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, values3: ArrayLike<T4>, iteratee: lodash.ValueIteratee<T1 | T2 | T3 | T4>): T1[];
        <T1, T2, T3, T4, T5>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, values3: ArrayLike<T4>, values4: ArrayLike<T5>, iteratee: lodash.ValueIteratee<T1 | T2 | T3 | T4 | T5>): T1[];
        <T1, T2, T3, T4, T5, T6>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, values3: ArrayLike<T4>, values4: ArrayLike<T5>, values5: ArrayLike<T6>, iteratee: lodash.ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>): T1[];
        <T1, T2, T3, T4, T5, T6, T7>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, values3: ArrayLike<T4>, values4: ArrayLike<T5>, values5: ArrayLike<T6>, ...values: (string | [string, any] | ArrayLike<T7> | ((value: T1 | T2 | T3 | T4 | T5 | T6 | T7) => lodash.NotVoid) | lodash.PartialDeep<T1> | lodash.PartialDeep<T2> | lodash.PartialDeep<T3> | lodash.PartialDeep<T4> | lodash.PartialDeep<T5> | lodash.PartialDeep<T6> | lodash.PartialDeep<T7>)[]): T1[];
        <T>(array: ArrayLike<T> | null | undefined, ...values: ArrayLike<T>[]): T[];
    };
    readonly differenceWith: {
        <T1, T2>(array: ArrayLike<T1> | null | undefined, values: ArrayLike<T2>, comparator: lodash.Comparator2<T1, T2>): T1[];
        <T1, T2, T3>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, comparator: lodash.Comparator2<T1, T2 | T3>): T1[];
        <T1, T2, T3, T4>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, ...values: (ArrayLike<T4> | lodash.Comparator2<T1, T2 | T3 | T4>)[]): T1[];
        <T>(array: ArrayLike<T> | null | undefined, ...values: ArrayLike<T>[]): T[];
    };
    readonly divide: (dividend: number, divisor: number) => number;
    readonly drop: <T>(array: ArrayLike<T> | null | undefined, n?: number | undefined) => T[];
    readonly dropRight: <T>(array: ArrayLike<T> | null | undefined, n?: number | undefined) => T[];
    readonly dropRightWhile: <T>(array: ArrayLike<T> | null | undefined, predicate?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined) => T[];
    readonly dropWhile: <T>(array: ArrayLike<T> | null | undefined, predicate?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined) => T[];
    readonly each: {
        <T>(collection: T[], iteratee?: lodash.ArrayIterator<T, any> | undefined): T[];
        (collection: string, iteratee?: lodash.StringIterator<any> | undefined): string;
        <T>(collection: ArrayLike<T>, iteratee?: lodash.ListIterator<T, any> | undefined): ArrayLike<T>;
        <T extends object>(collection: T, iteratee?: lodash.ObjectIterator<T, any> | undefined): T;
        <T, TArray extends T[] | null | undefined>(collection: (TArray & undefined) | (TArray & null) | (TArray & T[]), iteratee?: lodash.ArrayIterator<T, any> | undefined): TArray;
        <TString extends string | null | undefined>(collection: TString, iteratee?: lodash.StringIterator<any> | undefined): TString;
        <T, TList extends ArrayLike<T> | null | undefined>(collection: (TList & undefined) | (TList & null) | (TList & ArrayLike<T>), iteratee?: lodash.ListIterator<T, any> | undefined): TList;
        <T extends object>(collection: T | null | undefined, iteratee?: lodash.ObjectIterator<T, any> | undefined): T | null | undefined;
    };
    readonly eachRight: {
        <T>(collection: T[], iteratee?: lodash.ArrayIterator<T, any> | undefined): T[];
        (collection: string, iteratee?: lodash.StringIterator<any> | undefined): string;
        <T>(collection: ArrayLike<T>, iteratee?: lodash.ListIterator<T, any> | undefined): ArrayLike<T>;
        <T extends object>(collection: T, iteratee?: lodash.ObjectIterator<T, any> | undefined): T;
        <T, TArray extends T[] | null | undefined>(collection: (TArray & undefined) | (TArray & null) | (TArray & T[]), iteratee?: lodash.ArrayIterator<T, any> | undefined): TArray;
        <TString extends string | null | undefined>(collection: TString, iteratee?: lodash.StringIterator<any> | undefined): TString;
        <T, TList extends ArrayLike<T> | null | undefined>(collection: (TList & undefined) | (TList & null) | (TList & ArrayLike<T>), iteratee?: lodash.ListIterator<T, any> | undefined): TList;
        <T extends object>(collection: T | null | undefined, iteratee?: lodash.ObjectIterator<T, any> | undefined): T | null | undefined;
    };
    readonly endsWith: (string?: string | undefined, target?: string | undefined, position?: number | undefined) => boolean;
    readonly eq: (value: any, other: any) => boolean;
    readonly escape: (string?: string | undefined) => string;
    readonly escapeRegExp: (string?: string | undefined) => string;
    readonly every: {
        <T>(collection: ArrayLike<T> | null | undefined, predicate?: string | object | [string, any] | lodash.ListIterator<T, boolean> | lodash.PartialDeep<T> | undefined): boolean;
        <T>(collection: lodash.NumericDictionary<T> | null | undefined, predicate?: string | [string, any] | lodash.NumericDictionaryIterator<T, boolean> | lodash.PartialDeep<T> | undefined): boolean;
        <T extends object>(collection: T | null | undefined, predicate?: string | object | [string, any] | lodash.ObjectIterator<T, boolean> | lodash.PartialDeep<T[keyof T]> | undefined): boolean;
    };
    readonly filter: {
        (collection: string | null | undefined, predicate?: lodash.StringIterator<boolean> | undefined): string[];
        <T, S extends T>(collection: ArrayLike<T> | null | undefined, predicate: lodash.ListIteratorTypeGuard<T, S>): S[];
        <T>(collection: ArrayLike<T> | null | undefined, predicate?: string | object | [string, any] | lodash.ListIterator<T, boolean> | lodash.PartialDeep<T> | undefined): T[];
        <T extends object, S extends T[keyof T]>(collection: T | null | undefined, predicate: lodash.ObjectIteratorTypeGuard<T, S>): S[];
        <T extends object>(collection: T | null | undefined, predicate?: string | object | [string, any] | lodash.ObjectIterator<T, boolean> | lodash.PartialDeep<T[keyof T]> | undefined): T[keyof T][];
    };
    readonly find: {
        <T, S extends T>(collection: ArrayLike<T> | null | undefined, predicate: lodash.ListIteratorTypeGuard<T, S>, fromIndex?: number | undefined): S | undefined;
        <T>(collection: ArrayLike<T> | null | undefined, predicate?: string | object | [string, any] | lodash.ListIterator<T, boolean> | lodash.PartialDeep<T> | undefined, fromIndex?: number | undefined): T | undefined;
        <T extends object, S extends T[keyof T]>(collection: T | null | undefined, predicate: lodash.ObjectIteratorTypeGuard<T, S>, fromIndex?: number | undefined): S | undefined;
        <T extends object>(collection: T | null | undefined, predicate?: string | object | [string, any] | lodash.ObjectIterator<T, boolean> | lodash.PartialDeep<T[keyof T]> | undefined, fromIndex?: number | undefined): T[keyof T] | undefined;
    };
    readonly findKey: <T>(object: T | null | undefined, predicate?: string | [string, any] | lodash.ObjectIterator<T, lodash.NotVoid> | lodash.PartialDeep<T[keyof T]> | undefined) => string | undefined;
    readonly findLast: {
        <T, S extends T>(collection: ArrayLike<T> | null | undefined, predicate: lodash.ListIteratorTypeGuard<T, S>, fromIndex?: number | undefined): S | undefined;
        <T>(collection: ArrayLike<T> | null | undefined, predicate?: string | object | [string, any] | lodash.ListIterator<T, boolean> | lodash.PartialDeep<T> | undefined, fromIndex?: number | undefined): T | undefined;
        <T extends object, S extends T[keyof T]>(collection: T | null | undefined, predicate: lodash.ObjectIteratorTypeGuard<T, S>, fromIndex?: number | undefined): S | undefined;
        <T extends object>(collection: T | null | undefined, predicate?: string | object | [string, any] | lodash.ObjectIterator<T, boolean> | lodash.PartialDeep<T[keyof T]> | undefined, fromIndex?: number | undefined): T[keyof T] | undefined;
    };
    readonly findLastIndex: <T>(array: ArrayLike<T> | null | undefined, predicate?: string | object | [string, any] | lodash.ListIterator<T, boolean> | lodash.PartialDeep<T> | undefined, fromIndex?: number | undefined) => number;
    readonly findLastKey: <T>(object: T | null | undefined, predicate?: string | [string, any] | lodash.ObjectIterator<T, lodash.NotVoid> | lodash.PartialDeep<T[keyof T]> | undefined) => string | undefined;
    readonly first: <T>(array: ArrayLike<T> | null | undefined) => T | undefined;
    readonly flatMap: {
        <T>(collection: ArrayLike<lodash.Many<T>> | lodash.Dictionary<lodash.Many<T>> | lodash.NumericDictionary<lodash.Many<T>> | null | undefined): T[];
        (collection: object | null | undefined): any[];
        <T, TResult>(collection: ArrayLike<T> | null | undefined, iteratee: lodash.ListIterator<T, lodash.Many<TResult>>): TResult[];
        <T, TResult>(collection: lodash.NumericDictionary<T> | null | undefined, iteratee: lodash.NumericDictionaryIterator<T, lodash.Many<TResult>>): TResult[];
        <T extends object, TResult>(collection: T | null | undefined, iteratee: lodash.ObjectIterator<T, lodash.Many<TResult>>): TResult[];
        (collection: object | null | undefined, iteratee: string): any[];
        (collection: object | null | undefined, iteratee: object): boolean[];
    };
    readonly flatMapDeep: {
        <T>(collection: ArrayLike<T | lodash.ListOfRecursiveArraysOrValues<T>> | lodash.Dictionary<T | lodash.ListOfRecursiveArraysOrValues<T>> | lodash.NumericDictionary<T | lodash.ListOfRecursiveArraysOrValues<T>> | null | undefined): T[];
        <T, TResult>(collection: ArrayLike<T> | null | undefined, iteratee: lodash.ListIterator<T, TResult | lodash.ListOfRecursiveArraysOrValues<TResult>>): TResult[];
        <T, TResult>(collection: lodash.NumericDictionary<T> | null | undefined, iteratee: lodash.NumericDictionaryIterator<T, TResult | lodash.ListOfRecursiveArraysOrValues<TResult>>): TResult[];
        <T extends object, TResult>(collection: T | null | undefined, iteratee: lodash.ObjectIterator<T, TResult | lodash.ListOfRecursiveArraysOrValues<TResult>>): TResult[];
        (collection: object | null | undefined, iteratee: string): any[];
        (collection: object | null | undefined, iteratee: object): boolean[];
    };
    readonly flatMapDepth: {
        <T>(collection: ArrayLike<T | lodash.ListOfRecursiveArraysOrValues<T>> | lodash.Dictionary<T | lodash.ListOfRecursiveArraysOrValues<T>> | lodash.NumericDictionary<T | lodash.ListOfRecursiveArraysOrValues<T>> | null | undefined): T[];
        <T, TResult>(collection: ArrayLike<T> | null | undefined, iteratee: lodash.ListIterator<T, TResult | lodash.ListOfRecursiveArraysOrValues<TResult>>, depth?: number | undefined): TResult[];
        <T, TResult>(collection: lodash.NumericDictionary<T> | null | undefined, iteratee: lodash.NumericDictionaryIterator<T, TResult | lodash.ListOfRecursiveArraysOrValues<TResult>>, depth?: number | undefined): TResult[];
        <T extends object, TResult>(collection: T | null | undefined, iteratee: lodash.ObjectIterator<T, TResult | lodash.ListOfRecursiveArraysOrValues<TResult>>, depth?: number | undefined): TResult[];
        (collection: object | null | undefined, iteratee: string, depth?: number | undefined): any[];
        (collection: object | null | undefined, iteratee: object, depth?: number | undefined): boolean[];
    };
    readonly flatten: {
        <T>(array: lodash.ListOfRecursiveArraysOrValues<T> | null | undefined, isDeep: boolean): T[];
        <T>(array: ArrayLike<lodash.Many<T>> | null | undefined): T[];
    };
    readonly flattenDeep: <T>(array: lodash.ListOfRecursiveArraysOrValues<T> | null | undefined) => T[];
    readonly flattenDepth: <T>(array: lodash.ListOfRecursiveArraysOrValues<T> | null | undefined, depth?: number | undefined) => T[];
    readonly flip: <T extends (...args: any[]) => any>(func: T) => T;
    readonly floor: (n: number, precision?: number | undefined) => number;
    readonly flow: {
        <R1, R2>(f1: () => R1, f2: (a: R1) => R2): () => R2;
        <R1, R2, R3>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): () => R3;
        <R1, R2, R3, R4>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): () => R4;
        <R1, R2, R3, R4, R5>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): () => R5;
        <R1, R2, R3, R4, R5, R6>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): () => R6;
        <R1, R2, R3, R4, R5, R6, R7>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): () => R7;
        <R1, R2, R3, R4, R5, R6, R7>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: lodash.Many<(a: any) => any>[]): () => any;
        <A1, R1, R2>(f1: (a1: A1) => R1, f2: (a: R1) => R2): (a1: A1) => R2;
        <A1, R1, R2, R3>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1) => R3;
        <A1, R1, R2, R3, R4>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1) => R4;
        <A1, R1, R2, R3, R4, R5>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1) => R5;
        <A1, R1, R2, R3, R4, R5, R6>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1) => R6;
        <A1, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1) => R7;
        <A1, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: lodash.Many<(a: any) => any>[]): (a1: A1) => any;
        <A1, A2, R1, R2>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2) => R2;
        <A1, A2, R1, R2, R3>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2) => R3;
        <A1, A2, R1, R2, R3, R4>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2) => R4;
        <A1, A2, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2) => R5;
        <A1, A2, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2) => R6;
        <A1, A2, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2) => R7;
        <A1, A2, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: lodash.Many<(a: any) => any>[]): (a1: A1, a2: A2) => any;
        <A1, A2, A3, R1, R2>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2, a3: A3) => R2;
        <A1, A2, A3, R1, R2, R3>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2, a3: A3) => R3;
        <A1, A2, A3, R1, R2, R3, R4>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2, a3: A3) => R4;
        <A1, A2, A3, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2, a3: A3) => R5;
        <A1, A2, A3, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2, a3: A3) => R6;
        <A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2, a3: A3) => R7;
        <A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: lodash.Many<(a: any) => any>[]): (a1: A1, a2: A2, a3: A3) => any;
        <A1, A2, A3, A4, R1, R2>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2, a3: A3, a4: A4) => R2;
        <A1, A2, A3, A4, R1, R2, R3>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2, a3: A3, a4: A4) => R3;
        <A1, A2, A3, A4, R1, R2, R3, R4>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2, a3: A3, a4: A4) => R4;
        <A1, A2, A3, A4, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2, a3: A3, a4: A4) => R5;
        <A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2, a3: A3, a4: A4) => R6;
        <A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2, a3: A3, a4: A4) => R7;
        <A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: lodash.Many<(a: any) => any>[]): (a1: A1, a2: A2, a3: A3, a4: A4) => any;
        <A1, A2, A3, A4, R1, R2>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R2;
        <A1, A2, A3, A4, R1, R2, R3>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R3;
        <A1, A2, A3, A4, R1, R2, R3, R4>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R4;
        <A1, A2, A3, A4, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R5;
        <A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R6;
        <A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R7;
        <A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: lodash.Many<(a: any) => any>[]): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => any;
        (funcs: lodash.Many<(...args: any[]) => any>[]): (...args: any[]) => any;
    };
    readonly flowRight: {
        <R2, R1>(f2: (a: R1) => R2, f1: () => R1): () => R2;
        <R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R3;
        <R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R4;
        <R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R5;
        <R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R6;
        <R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R7;
        <A1, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R2;
        <A1, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R3;
        <A1, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R4;
        <A1, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R5;
        <A1, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R6;
        <A1, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R7;
        <A1, A2, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R2;
        <A1, A2, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R3;
        <A1, A2, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R4;
        <A1, A2, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R5;
        <A1, A2, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R6;
        <A1, A2, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R7;
        <A1, A2, A3, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R2;
        <A1, A2, A3, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R3;
        <A1, A2, A3, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R4;
        <A1, A2, A3, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R5;
        <A1, A2, A3, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R6;
        <A1, A2, A3, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R7;
        <A1, A2, A3, A4, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R2;
        <A1, A2, A3, A4, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R3;
        <A1, A2, A3, A4, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R4;
        <A1, A2, A3, A4, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R5;
        <A1, A2, A3, A4, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R6;
        <A1, A2, A3, A4, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R7;
        <R2, R1>(f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R2;
        <R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R3;
        <R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R4;
        <R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R5;
        <R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R6;
        <R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R7;
        (f7: (a: any) => any, f6: (a: any) => any, f5: (a: any) => any, f4: (a: any) => any, f3: (a: any) => any, f2: (a: any) => any, f1: () => any, ...funcs: lodash.Many<(...args: any[]) => any>[]): (...args: any[]) => any;
        (funcs: lodash.Many<(...args: any[]) => any>[]): (...args: any[]) => any;
    };
    readonly forEach: {
        <T>(collection: T[], iteratee?: lodash.ArrayIterator<T, any> | undefined): T[];
        (collection: string, iteratee?: lodash.StringIterator<any> | undefined): string;
        <T>(collection: ArrayLike<T>, iteratee?: lodash.ListIterator<T, any> | undefined): ArrayLike<T>;
        <T extends object>(collection: T, iteratee?: lodash.ObjectIterator<T, any> | undefined): T;
        <T, TArray extends T[] | null | undefined>(collection: (TArray & undefined) | (TArray & null) | (TArray & T[]), iteratee?: lodash.ArrayIterator<T, any> | undefined): TArray;
        <TString extends string | null | undefined>(collection: TString, iteratee?: lodash.StringIterator<any> | undefined): TString;
        <T, TList extends ArrayLike<T> | null | undefined>(collection: (TList & undefined) | (TList & null) | (TList & ArrayLike<T>), iteratee?: lodash.ListIterator<T, any> | undefined): TList;
        <T extends object>(collection: T | null | undefined, iteratee?: lodash.ObjectIterator<T, any> | undefined): T | null | undefined;
    };
    readonly forEachRight: {
        <T>(collection: T[], iteratee?: lodash.ArrayIterator<T, any> | undefined): T[];
        (collection: string, iteratee?: lodash.StringIterator<any> | undefined): string;
        <T>(collection: ArrayLike<T>, iteratee?: lodash.ListIterator<T, any> | undefined): ArrayLike<T>;
        <T extends object>(collection: T, iteratee?: lodash.ObjectIterator<T, any> | undefined): T;
        <T, TArray extends T[] | null | undefined>(collection: (TArray & undefined) | (TArray & null) | (TArray & T[]), iteratee?: lodash.ArrayIterator<T, any> | undefined): TArray;
        <TString extends string | null | undefined>(collection: TString, iteratee?: lodash.StringIterator<any> | undefined): TString;
        <T, TList extends ArrayLike<T> | null | undefined>(collection: (TList & undefined) | (TList & null) | (TList & ArrayLike<T>), iteratee?: lodash.ListIterator<T, any> | undefined): TList;
        <T extends object>(collection: T | null | undefined, iteratee?: lodash.ObjectIterator<T, any> | undefined): T | null | undefined;
    };
    readonly forOwn: {
        <T>(object: T, iteratee?: lodash.ObjectIterator<T, any> | undefined): T;
        <T>(object: T | null | undefined, iteratee?: lodash.ObjectIterator<T, any> | undefined): T | null | undefined;
    };
    readonly forOwnRight: {
        <T>(object: T, iteratee?: lodash.ObjectIterator<T, any> | undefined): T;
        <T>(object: T | null | undefined, iteratee?: lodash.ObjectIterator<T, any> | undefined): T | null | undefined;
    };
    readonly fromPairs: {
        <T>(pairs: ArrayLike<[PropertyKey, T]> | null | undefined): lodash.Dictionary<T>;
        (pairs: ArrayLike<any[]> | null | undefined): lodash.Dictionary<any>;
    };
    readonly functions: (object: any) => string[];
    readonly get: {
        <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [TKey]): TObject[TKey];
        <TObject extends object, TKey extends keyof TObject>(object: TObject | null | undefined, path: TKey | [TKey]): TObject[TKey] | undefined;
        <TObject extends object, TKey extends keyof TObject, TDefault>(object: TObject | null | undefined, path: TKey | [TKey], defaultValue: TDefault): TDefault | TObject[TKey];
        <T>(object: lodash.NumericDictionary<T>, path: number): T;
        <T>(object: lodash.NumericDictionary<T> | null | undefined, path: number): T | undefined;
        <T, TDefault>(object: lodash.NumericDictionary<T> | null | undefined, path: number, defaultValue: TDefault): T | TDefault;
        <TDefault>(object: null | undefined, path: lodash.Many<PropertyKey>, defaultValue: TDefault): TDefault;
        (object: null | undefined, path: lodash.Many<PropertyKey>): undefined;
        (object: any, path: lodash.Many<PropertyKey>, defaultValue?: any): any;
    };
    readonly groupBy: {
        (collection: string | null | undefined, iteratee?: lodash.StringIterator<lodash.NotVoid> | undefined): lodash.Dictionary<string[]>;
        <T>(collection: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined): lodash.Dictionary<T[]>;
        <T>(collection: lodash.NumericDictionary<T> | null | undefined, iteratee?: string | [string, any] | lodash.NumericDictionaryIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined): lodash.Dictionary<T[]>;
        <T extends object>(collection: T | null | undefined, iteratee?: string | [string, any] | lodash.ObjectIterator<T, lodash.NotVoid> | lodash.PartialDeep<T[keyof T]> | undefined): lodash.Dictionary<T[keyof T][]>;
    };
    readonly gt: (value: any, other: any) => boolean;
    readonly gte: (value: any, other: any) => boolean;
    readonly has: <T>(object: T, path: lodash.Many<PropertyKey>) => boolean;
    readonly hasIn: <T>(object: T, path: lodash.Many<PropertyKey>) => boolean;
    readonly head: <T>(array: ArrayLike<T> | null | undefined) => T | undefined;
    readonly identity: {
        <T>(value: T): T;
        (): undefined;
    };
    readonly inRange: (n: number, start: number, end?: number | undefined) => boolean;
    readonly indexOf: <T>(array: ArrayLike<T> | null | undefined, value: T, fromIndex?: number | boolean | undefined) => number;
    readonly initial: <T>(array: ArrayLike<T> | null | undefined) => T[];
    readonly intersection: <T>(...arrays: ArrayLike<T>[]) => T[];
    readonly intersectionBy: {
        <T1, T2>(array: ArrayLike<T1> | null, values: ArrayLike<T2>, iteratee: lodash.ValueIteratee<T1 | T2>): T1[];
        <T1, T2, T3>(array: ArrayLike<T1> | null, values1: ArrayLike<T2>, values2: ArrayLike<T3>, iteratee: lodash.ValueIteratee<T1 | T2 | T3>): T1[];
        <T1, T2, T3, T4>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, ...values: (string | [string, any] | ArrayLike<T4> | ((value: T1 | T2 | T3 | T4) => lodash.NotVoid) | lodash.PartialDeep<T1> | lodash.PartialDeep<T2> | lodash.PartialDeep<T3> | lodash.PartialDeep<T4>)[]): T1[];
        <T>(array?: ArrayLike<T> | null | undefined, ...values: ArrayLike<T>[]): T[];
    };
    readonly intersectionWith: {
        <T1, T2>(array: ArrayLike<T1> | null | undefined, values: ArrayLike<T2>, comparator: lodash.Comparator2<T1, T2>): T1[];
        <T1, T2, T3>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, comparator: lodash.Comparator2<T1, T2 | T3>): T1[];
        <T1, T2, T3, T4>(array: ArrayLike<T1> | null | undefined, values1: ArrayLike<T2>, values2: ArrayLike<T3>, ...values: (ArrayLike<T4> | lodash.Comparator2<T1, T2 | T3 | T4>)[]): T1[];
        <T>(array?: ArrayLike<T> | null | undefined, ...values: ArrayLike<T>[]): T[];
    };
    readonly invert: (object: object) => lodash.Dictionary<string>;
    readonly invertBy: {
        <T>(object: ArrayLike<T> | lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined, interatee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined): lodash.Dictionary<string[]>;
        <T extends object>(object: T | null | undefined, interatee?: string | [string, any] | ((value: T[keyof T]) => lodash.NotVoid) | lodash.PartialDeep<T[keyof T]> | undefined): lodash.Dictionary<string[]>;
    };
    readonly invoke: (object: any, path: lodash.Many<PropertyKey>, ...args: any[]) => any;
    readonly invokeMap: {
        (collection: object | null | undefined, methodName: string, ...args: any[]): any[];
        <TResult>(collection: object | null | undefined, method: (...args: any[]) => TResult, ...args: any[]): TResult[];
    };
    readonly isArguments: (value?: any) => value is IArguments;
    readonly isArrayBuffer: (value?: any) => value is ArrayBuffer;
    readonly isArrayLike: {
        <T>(value: T & string & number): boolean;
        (value: Function | ((...args: any[]) => any) | null | undefined): value is never;
        (value: any): value is {
            length: number;
        };
    };
    readonly isArrayLikeObject: {
        <T>(value: T & string & number): boolean;
        (value: string | number | boolean | Function | ((...args: any[]) => any) | null | undefined): value is never;
        <T extends object>(value: string | number | boolean | T | null | undefined): value is T & {
            length: number;
        };
    };
    readonly isBoolean: (value?: any) => value is boolean;
    readonly isBuffer: (value?: any) => boolean;
    readonly isDate: (value?: any) => value is Date;
    readonly isElement: (value?: any) => boolean;
    readonly isEmpty: (value?: any) => boolean;
    readonly isEqual: (value: any, other: any) => boolean;
    readonly isEqualWith: (value: any, other: any, customizer?: lodash.IsEqualCustomizer | undefined) => boolean;
    readonly isError: (value: any) => value is Error;
    readonly isFunction: (value: any) => value is (...args: any[]) => any;
    readonly isLength: (value?: any) => boolean;
    readonly isMap: (value?: any) => value is Map<any, any>;
    readonly isMatch: (object: object, source: object) => boolean;
    readonly isMatchWith: (object: object, source: object, customizer: lodash.isMatchWithCustomizer) => boolean;
    readonly isNative: (value: any) => value is Function | ((...args: any[]) => any);
    readonly isNil: (value: any) => value is null | undefined;
    readonly isNull: (value: any) => value is null;
    readonly isNumber: (value?: any) => value is number;
    readonly isObject: (value?: any) => boolean;
    readonly isObjectLike: (value?: any) => boolean;
    readonly isPlainObject: (value?: any) => boolean;
    readonly isRegExp: (value?: any) => value is RegExp;
    readonly isSet: (value?: any) => value is Set<any>;
    readonly isString: (value?: any) => value is string;
    readonly isSymbol: (value: any) => boolean;
    readonly isTypedArray: (value: any) => boolean;
    readonly isUndefined: (value: any) => value is undefined;
    readonly isWeakMap: (value?: any) => value is WeakMap<object, any>;
    readonly isWeakSet: (value?: any) => value is WeakSet<object>;
    readonly kebabCase: (string?: string | undefined) => string;
    readonly keyBy: {
        (collection: string | null | undefined, iteratee?: lodash.StringIterator<PropertyKey> | undefined): lodash.Dictionary<string>;
        <T>(collection: ArrayLike<T> | null | undefined, iteratee?: string | object | [string, any] | lodash.ListIterator<T, PropertyKey> | lodash.PartialDeep<T> | undefined): lodash.Dictionary<T>;
        <T extends object>(collection: T | null | undefined, iteratee?: string | object | [string, any] | lodash.ObjectIterator<T, PropertyKey> | lodash.PartialDeep<T[keyof T]> | undefined): lodash.Dictionary<T[keyof T]>;
        <T>(collection: lodash.NumericDictionary<T> | null | undefined, iteratee?: string | [string, any] | lodash.NumericDictionaryIterator<T, PropertyKey> | lodash.PartialDeep<T> | undefined): lodash.Dictionary<T>;
    };
    readonly keys: (object?: any) => string[];
    readonly last: <T>(array: ArrayLike<T> | null | undefined) => T | undefined;
    readonly lastIndexOf: <T>(array: ArrayLike<T> | null | undefined, value: T, fromIndex?: number | true | undefined) => number;
    readonly lowerCase: (string?: string | undefined) => string;
    readonly lowerFirst: (string?: string | undefined) => string;
    readonly lt: (value: any, other: any) => boolean;
    readonly lte: (value: any, other: any) => boolean;
    readonly map: {
        <T, TResult>(collection: ArrayLike<T> | null | undefined, iteratee: lodash.ListIterator<T, TResult>): TResult[];
        <T>(collection: ArrayLike<T> | lodash.Dictionary<T> | null | undefined): T[];
        <T, TResult>(collection: lodash.Dictionary<T> | null | undefined, iteratee: lodash.ObjectIterator<lodash.Dictionary<T>, TResult>): TResult[];
        <T, K extends keyof T>(collection: ArrayLike<T> | lodash.Dictionary<T> | null | undefined, iteratee: K): T[K][];
        <T, TResult>(collection: lodash.NumericDictionary<T> | null | undefined, iteratee?: lodash.NumericDictionaryIterator<T, TResult> | undefined): TResult[];
        <T, TResult>(collection: ArrayLike<T> | lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined, iteratee?: string | undefined): TResult[];
        <T>(collection: ArrayLike<T> | lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined, iteratee?: object | undefined): boolean[];
    };
    readonly mapValues: {
        <T extends object, TResult>(obj: T | null | undefined, callback: lodash.ObjectIterator<T, TResult>): {
            [P in keyof T]: TResult;
        };
        <T extends object>(obj: T | null | undefined, iteratee: object): {
            [P in keyof T]: boolean;
        };
        <T, TKey extends keyof T>(obj: lodash.Dictionary<T> | null | undefined, iteratee: TKey): lodash.Dictionary<T[TKey]>;
        <T extends object, TKey extends keyof T>(obj: T | null | undefined, iteratee: string): {
            [P in keyof T]: any;
        };
        <TResult>(obj: string | null | undefined, callback: lodash.StringIterator<TResult>): lodash.NumericDictionary<TResult>;
        <T>(obj: lodash.Dictionary<T> | null | undefined): lodash.Dictionary<T>;
        <T extends object>(obj: T): T;
        <T extends object>(obj: T | null | undefined): {} | T;
        (obj: string | null | undefined): lodash.NumericDictionary<string>;
    };
    readonly matches: {
        <T>(source: T): (value: any) => boolean;
        <T, V>(source: T): (value: V) => boolean;
    };
    readonly matchesProperty: {
        <T>(path: lodash.Many<PropertyKey>, srcValue: T): (value: any) => boolean;
        <T, V>(path: lodash.Many<PropertyKey>, srcValue: T): (value: V) => boolean;
    };
    readonly maxBy: <T>(collection: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined) => T | undefined;
    readonly mean: (collection: ArrayLike<any> | null | undefined) => number;
    readonly meanBy: <T>(collection: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined) => number;
    readonly memoize: {
        <T extends (...args: any[]) => any>(func: T, resolver?: ((...args: any[]) => any) | undefined): T & lodash.MemoizedFunction;
        Cache: lodash.MapCacheConstructor;
    };
    readonly merge: {
        <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
        <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;
        <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;
        <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        (object: any, ...otherArgs: any[]): any;
    };
    readonly mergeWith: {
        <TObject, TSource>(object: TObject, source: TSource, customizer: (value: any, srcValue: any, key: string, object: any, source: any) => any): TObject & TSource;
        <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: (value: any, srcValue: any, key: string, object: any, source: any) => any): TObject & TSource1 & TSource2;
        <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: (value: any, srcValue: any, key: string, object: any, source: any) => any): TObject & TSource1 & TSource2 & TSource3;
        <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: (value: any, srcValue: any, key: string, object: any, source: any) => any): TObject & TSource1 & TSource2 & TSource3 & TSource4;
        (object: any, ...otherArgs: any[]): any;
    };
    readonly method: (path: lodash.Many<PropertyKey>, ...args: any[]) => (object: any) => any;
    readonly methodOf: (object: object, ...args: any[]) => (path: lodash.Many<PropertyKey>) => any;
    readonly minBy: <T>(collection: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined) => T | undefined;
    readonly multiply: (multiplier: number, multiplicand: number) => number;
    readonly negate: <T extends (...args: any[]) => any>(predicate: T) => T;
    readonly nth: <T>(array: ArrayLike<T> | null | undefined, n?: number | undefined) => T | undefined;
    readonly nthArg: (n?: number | undefined) => (...args: any[]) => any;
    readonly once: <T extends (...args: any[]) => any>(func: T) => T;
    readonly orderBy: {
        <T>(collection: ArrayLike<T> | null | undefined, iteratees?: lodash.ListIterator<T, lodash.NotVoid> | lodash.ListIterator<T, lodash.NotVoid>[] | undefined, orders?: string | boolean | (string | boolean)[] | undefined): T[];
        <T>(collection: ArrayLike<T> | null | undefined, iteratees?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | lodash.ListIteratee<T>[] | undefined, orders?: string | boolean | (string | boolean)[] | undefined): T[];
        <T extends object>(collection: T | null | undefined, iteratees?: lodash.ObjectIterator<T, lodash.NotVoid> | lodash.ObjectIterator<T, lodash.NotVoid>[] | undefined, orders?: string | boolean | (string | boolean)[] | undefined): T[keyof T][];
        <T extends object>(collection: T | null | undefined, iteratees?: string | [string, any] | lodash.ObjectIterator<T, lodash.NotVoid> | lodash.PartialDeep<T[keyof T]> | lodash.ObjectIteratee<T>[] | undefined, orders?: string | boolean | (string | boolean)[] | undefined): T[keyof T][];
        <T>(collection: lodash.NumericDictionary<T> | null | undefined, iteratees?: lodash.NumericDictionaryIterator<T, lodash.NotVoid> | lodash.NumericDictionaryIterator<T, lodash.NotVoid>[] | undefined, orders?: string | boolean | (string | boolean)[] | undefined): T[];
        <T>(collection: lodash.NumericDictionary<T> | null | undefined, iteratees?: string | [string, any] | lodash.NumericDictionaryIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | lodash.NumericDictionaryIteratee<T>[] | undefined, orders?: string | boolean | (string | boolean)[] | undefined): T[];
    };
    readonly over: <TResult>(...iteratees: lodash.Many<(...args: any[]) => TResult>[]) => (...args: any[]) => TResult[];
    readonly overArgs: (func: (...args: any[]) => any, ...transforms: lodash.Many<(...args: any[]) => any>[]) => (...args: any[]) => any;
    readonly overEvery: <T>(...predicates: lodash.Many<(...args: T[]) => boolean>[]) => (...args: T[]) => boolean;
    readonly overSome: <T>(...predicates: lodash.Many<(...args: T[]) => boolean>[]) => (...args: T[]) => boolean;
    readonly pad: (string?: string | undefined, length?: number | undefined, chars?: string | undefined) => string;
    readonly padEnd: (string?: string | undefined, length?: number | undefined, chars?: string | undefined) => string;
    readonly padStart: (string?: string | undefined, length?: number | undefined, chars?: string | undefined) => string;
    readonly parseInt: (string: string, radix?: number | undefined) => number;
    readonly partial: lodash.Partial;
    readonly partialRight: lodash.PartialRight;
    readonly partition: {
        <T>(collection: ArrayLike<T> | null | undefined, callback: lodash.ValueIteratee<T>): [T[], T[]];
        <T extends object>(collection: T | null | undefined, callback: lodash.ValueIteratee<T[keyof T]>): [T[keyof T][], T[keyof T][]];
    };
    readonly pick: {
        <T extends object, U extends keyof T>(object: T, ...props: lodash.Many<U>[]): Pick<T, U>;
        <T>(object: T | null | undefined, ...props: lodash.Many<PropertyKey>[]): lodash.PartialDeep<T>;
    };
    readonly pickBy: <T extends object>(object: T | null | undefined, predicate?: string | [string, any] | ((value: T[keyof T], key: string) => lodash.NotVoid) | lodash.PartialDeep<T[keyof T]> | undefined) => Partial<T>;
    readonly property: <TObj, TResult>(path: lodash.Many<PropertyKey>) => (obj: TObj) => TResult;
    readonly propertyOf: <T extends {}>(object: T) => (path: lodash.Many<PropertyKey>) => any;
    readonly pull: {
        <T>(array: T[], ...values: T[]): T[];
        <T>(array: ArrayLike<T>, ...values: T[]): ArrayLike<T>;
    };
    readonly pullAll: {
        <T>(array: T[], values?: ArrayLike<T> | undefined): T[];
        <T>(array: ArrayLike<T>, values?: ArrayLike<T> | undefined): ArrayLike<T>;
    };
    readonly pullAllBy: {
        <T>(array: T[], values?: ArrayLike<T> | undefined, iteratee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined): T[];
        <T>(array: ArrayLike<T>, values?: ArrayLike<T> | undefined, iteratee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined): ArrayLike<T>;
        <T1, T2>(array: T1[], values: ArrayLike<T2>, iteratee: lodash.ValueIteratee<T1 | T2>): T1[];
        <T1, T2>(array: ArrayLike<T1>, values: ArrayLike<T2>, iteratee: lodash.ValueIteratee<T1 | T2>): ArrayLike<T1>;
    };
    readonly pullAllWith: {
        <T>(array: T[], values?: ArrayLike<T> | undefined, comparator?: lodash.Comparator<T> | undefined): T[];
        <T>(array: ArrayLike<T>, values?: ArrayLike<T> | undefined, comparator?: lodash.Comparator<T> | undefined): ArrayLike<T>;
        <T1, T2>(array: T1[], values: ArrayLike<T2>, comparator: lodash.Comparator2<T1, T2>): T1[];
        <T1, T2>(array: ArrayLike<T1>, values: ArrayLike<T2>, comparator: lodash.Comparator2<T1, T2>): ArrayLike<T1>;
    };
    readonly pullAt: {
        <T>(array: T[], ...indexes: (number | number[])[]): T[];
        <T>(array: ArrayLike<T>, ...indexes: (number | number[])[]): ArrayLike<T>;
    };
    readonly random: {
        (floating?: boolean | undefined): number;
        (max: number, floating?: boolean | undefined): number;
        (min: number, max: number, floating?: boolean | undefined): number;
        (min: number, index: string | number, guard: object): number;
    };
    readonly range: {
        (start: number, end?: number | undefined, step?: number | undefined): number[];
        (end: number, index: string | number, guard: object): number[];
    };
    readonly rangeRight: {
        (start: number, end?: number | undefined, step?: number | undefined): number[];
        (end: number, index: string | number, guard: object): number[];
    };
    readonly reduce: {
        <T, TResult>(collection: T[] | null | undefined, callback: lodash.MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult;
        <T, TResult>(collection: ArrayLike<T> | null | undefined, callback: lodash.MemoListIterator<T, TResult, ArrayLike<T>>, accumulator: TResult): TResult;
        <T extends object, TResult>(collection: T | null | undefined, callback: lodash.MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult;
        <T, TResult>(collection: lodash.NumericDictionary<T> | null | undefined, callback: lodash.MemoListIterator<T, TResult, lodash.NumericDictionary<T>>, accumulator: TResult): TResult;
        <T, TResult>(collection: T[] | null | undefined, callback: lodash.MemoListIterator<T, TResult, T[]>): TResult | undefined;
        <T, TResult>(collection: ArrayLike<T> | null | undefined, callback: lodash.MemoListIterator<T, TResult, ArrayLike<T>>): TResult | undefined;
        <T extends object, TResult>(collection: T | null | undefined, callback: lodash.MemoObjectIterator<T[keyof T], TResult, T>): TResult | undefined;
        <T, TResult>(collection: lodash.NumericDictionary<T> | null | undefined, callback: lodash.MemoListIterator<T, TResult, lodash.NumericDictionary<T>>): TResult | undefined;
    };
    readonly reduceRight: {
        <T, TResult>(collection: T[] | null | undefined, callback: lodash.MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult;
        <T, TResult>(collection: ArrayLike<T> | null | undefined, callback: lodash.MemoListIterator<T, TResult, ArrayLike<T>>, accumulator: TResult): TResult;
        <T extends object, TResult>(collection: T | null | undefined, callback: lodash.MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult;
        <T, TResult>(collection: lodash.NumericDictionary<T> | null | undefined, callback: lodash.MemoListIterator<T, TResult, lodash.NumericDictionary<T>>, accumulator: TResult): TResult;
        <T, TResult>(collection: T[] | null | undefined, callback: lodash.MemoListIterator<T, TResult, T[]>): TResult | undefined;
        <T, TResult>(collection: ArrayLike<T> | null | undefined, callback: lodash.MemoListIterator<T, TResult, ArrayLike<T>>): TResult | undefined;
        <T extends object, TResult>(collection: T | null | undefined, callback: lodash.MemoObjectIterator<T[keyof T], TResult, T>): TResult | undefined;
        <T, TResult>(collection: lodash.NumericDictionary<T> | null | undefined, callback: lodash.MemoListIterator<T, TResult, lodash.NumericDictionary<T>>): TResult | undefined;
    };
    readonly reject: {
        (collection: string | null | undefined, predicate?: lodash.StringIterator<boolean> | undefined): string[];
        <T>(collection: ArrayLike<T> | null | undefined, predicate?: string | object | [string, any] | lodash.ListIterator<T, boolean> | lodash.PartialDeep<T> | undefined): T[];
        <T extends object>(collection: T | null | undefined, predicate?: string | object | [string, any] | lodash.ObjectIterator<T, boolean> | lodash.PartialDeep<T[keyof T]> | undefined): T[keyof T][];
    };
    readonly remove: <T>(array: ArrayLike<T>, predicate?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined) => T[];
    readonly repeat: (string?: string | undefined, n?: number | undefined) => string;
    readonly replace: {
        (string: string, pattern: string | RegExp, replacement: string | lodash.ReplaceFunction): string;
        (pattern: string | RegExp, replacement: string | lodash.ReplaceFunction): string;
    };
    readonly result: <TResult>(object: any, path: lodash.Many<PropertyKey>, defaultValue?: TResult | ((...args: any[]) => TResult) | undefined) => TResult;
    readonly round: (n: number, precision?: number | undefined) => number;
    readonly sample: {
        <T>(collection: ArrayLike<T> | lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): T | undefined;
        <T extends object>(collection: T): T[keyof T];
        <T extends object>(collection: T | null | undefined): T[keyof T] | undefined;
    };
    readonly sampleSize: {
        <T>(collection: ArrayLike<T> | lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined, n?: number | undefined): T[];
        <T extends object>(collection: T | null | undefined, n?: number | undefined): T[keyof T][];
    };
    readonly set: {
        <T extends object>(object: T, path: lodash.Many<PropertyKey>, value: any): T;
        <TResult>(object: object, path: lodash.Many<PropertyKey>, value: any): TResult;
    };
    readonly setWith: {
        <T extends object>(object: T, path: lodash.Many<PropertyKey>, value: any, customizer?: lodash.SetWithCustomizer<T> | undefined): T;
        <T extends object, TResult>(object: T, path: lodash.Many<PropertyKey>, value: any, customizer?: lodash.SetWithCustomizer<T> | undefined): TResult;
    };
    readonly shuffle: {
        <T>(collection: ArrayLike<T> | null | undefined): T[];
        <T extends object>(collection: T | null | undefined): T[keyof T][];
    };
    readonly size: (collection: string | object | null | undefined) => number;
    readonly slice: <T>(array: ArrayLike<T> | null | undefined, start?: number | undefined, end?: number | undefined) => T[];
    readonly snakeCase: (string?: string | undefined) => string;
    readonly some: {
        <T>(collection: ArrayLike<T> | null | undefined, predicate?: string | object | [string, any] | lodash.ListIterator<T, boolean> | lodash.PartialDeep<T> | undefined): boolean;
        <T extends object>(collection: T | null | undefined, predicate?: string | object | [string, any] | lodash.ObjectIterator<T, boolean> | lodash.PartialDeep<T[keyof T]> | undefined): boolean;
        <T>(collection: lodash.NumericDictionary<T> | null | undefined, predicate?: string | [string, any] | lodash.NumericDictionaryIterator<T, boolean> | lodash.PartialDeep<T> | undefined): boolean;
    };
    readonly sortBy: {
        <T>(collection: ArrayLike<T> | null | undefined, ...iteratees: lodash.Many<lodash.ListIteratee<T>>[]): T[];
        <T extends object>(collection: T | null | undefined, ...iteratees: lodash.Many<lodash.ObjectIteratee<T>>[]): T[keyof T][];
    };
    readonly sortedIndex: <T>(array: ArrayLike<T> | null | undefined, value: T) => number;
    readonly sortedIndexBy: <T>(array: ArrayLike<T> | null | undefined, value: T, iteratee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined) => number;
    readonly sortedIndexOf: <T>(array: ArrayLike<T> | null | undefined, value: T) => number;
    readonly sortedLastIndex: <T>(array: ArrayLike<T> | null | undefined, value: T) => number;
    readonly sortedLastIndexBy: <T>(array: ArrayLike<T> | null | undefined, value: T, iteratee: lodash.ValueIteratee<T>) => number;
    readonly sortedLastIndexOf: <T>(array: ArrayLike<T> | null | undefined, value: T) => number;
    readonly sortedUniq: <T>(array: ArrayLike<T> | null | undefined) => T[];
    readonly sortedUniqBy: {
        (array: string | null | undefined, iteratee: lodash.StringIterator<lodash.NotVoid>): string[];
        <T>(array: ArrayLike<T> | null | undefined, iteratee: lodash.ListIteratee<T>): T[];
    };
    readonly split: {
        (string: string, separator?: string | RegExp | undefined, limit?: number | undefined): string[];
        (string: string, index: string | number, guard: object): string[];
    };
    readonly startCase: (string?: string | undefined) => string;
    readonly startsWith: (string?: string | undefined, target?: string | undefined, position?: number | undefined) => boolean;
    readonly subtract: (minuend: number, subtrahend: number) => number;
    readonly sum: (collection: ArrayLike<any> | null | undefined) => number;
    readonly sumBy: <T>(collection: ArrayLike<T> | null | undefined, iteratee?: string | ((value: T) => number) | undefined) => number;
    readonly tail: <T>(array: ArrayLike<T> | null | undefined) => T[];
    readonly take: <T>(array: ArrayLike<T> | null | undefined, n?: number | undefined) => T[];
    readonly takeRight: <T>(array: ArrayLike<T> | null | undefined, n?: number | undefined) => T[];
    readonly takeRightWhile: <T>(array: ArrayLike<T> | null | undefined, predicate?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined) => T[];
    readonly takeWhile: <T>(array: ArrayLike<T> | null | undefined, predicate?: string | [string, any] | lodash.ListIterator<T, lodash.NotVoid> | lodash.PartialDeep<T> | undefined) => T[];
    readonly template: (string?: string | undefined, options?: lodash.TemplateOptions | undefined) => lodash.TemplateExecutor;
    readonly templateSettings: lodash.TemplateSettings;
    readonly throttle: <T extends (...args: any[]) => any>(func: T, wait?: number | undefined, options?: lodash.ThrottleSettings | undefined) => T & lodash.Cancelable;
    readonly times: {
        <TResult>(n: number, iteratee: (num: number) => TResult): TResult[];
        (n: number): number[];
    };
    readonly toArray: {
        <T>(value: ArrayLike<T> | lodash.Dictionary<T> | lodash.NumericDictionary<T> | null | undefined): T[];
        <T>(value: T): T[keyof T][];
        (): any[];
    };
    readonly toFinite: (value: any) => number;
    readonly toInteger: (value: any) => number;
    readonly toLength: (value: any) => number;
    readonly toNumber: (value: any) => number;
    readonly toPath: (value: any) => string[];
    readonly toPlainObject: (value?: any) => any;
    readonly toSafeInteger: (value: any) => number;
    readonly toString: (value: any) => string;
    readonly transform: {
        <T, TResult>(object: T[], iteratee: lodash.MemoVoidArrayIterator<T, TResult[]>, accumulator?: TResult[] | undefined): TResult[];
        <T, TResult>(object: T[], iteratee: lodash.MemoVoidArrayIterator<T, lodash.Dictionary<TResult>>, accumulator: lodash.Dictionary<TResult>): lodash.Dictionary<TResult>;
        <T, TResult>(object: lodash.Dictionary<T>, iteratee: lodash.MemoVoidDictionaryIterator<T, lodash.Dictionary<TResult>>, accumulator?: lodash.Dictionary<TResult> | undefined): lodash.Dictionary<TResult>;
        <T, TResult>(object: lodash.Dictionary<T>, iteratee: lodash.MemoVoidDictionaryIterator<T, TResult[]>, accumulator: TResult[]): TResult[];
        (object: any[]): any[];
        (object: object): lodash.Dictionary<any>;
    };
    readonly trim: {
        (string?: string | undefined, chars?: string | undefined): string;
        (string: string, index: string | number, guard: object): string;
    };
    readonly trimEnd: {
        (string?: string | undefined, chars?: string | undefined): string;
        (string: string, index: string | number, guard: object): string;
    };
    readonly trimStart: {
        (string?: string | undefined, chars?: string | undefined): string;
        (string: string, index: string | number, guard: object): string;
    };
    readonly truncate: (string?: string | undefined, options?: lodash.TruncateOptions | undefined) => string;
    readonly unescape: (string?: string | undefined) => string;
    readonly union: <T>(...arrays: (ArrayLike<T> | null | undefined)[]) => T[];
    readonly unionBy: {
        <T>(arrays: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined): T[];
        <T>(arrays1: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined): T[];
        <T>(arrays1: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, arrays3: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined): T[];
        <T>(arrays1: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, arrays3: ArrayLike<T> | null | undefined, arrays4: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined): T[];
        <T>(arrays1: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, arrays3: ArrayLike<T> | null | undefined, arrays4: ArrayLike<T> | null | undefined, arrays5: ArrayLike<T> | null | undefined, ...iteratee: (string | [string, any] | ArrayLike<T> | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | null | undefined)[]): T[];
    };
    readonly unionWith: {
        <T>(arrays: ArrayLike<T> | null | undefined, comparator?: lodash.Comparator<T> | undefined): T[];
        <T>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, comparator?: lodash.Comparator<T> | undefined): T[];
        <T>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, arrays3: ArrayLike<T> | null | undefined, ...comparator: (ArrayLike<T> | lodash.Comparator<T> | null | undefined)[]): T[];
    };
    readonly uniq: <T>(array: ArrayLike<T> | null | undefined) => T[];
    readonly uniqBy: {
        (array: string | null | undefined, iteratee: lodash.StringIterator<lodash.NotVoid>): string[];
        <T>(array: ArrayLike<T> | null | undefined, iteratee: lodash.ListIteratee<T>): T[];
    };
    readonly uniqWith: <T>(array: ArrayLike<T> | null | undefined, comparator?: lodash.Comparator<T> | undefined) => T[];
    readonly uniqueId: (prefix?: string | undefined) => string;
    readonly unset: (object: any, path: lodash.Many<PropertyKey>) => boolean;
    readonly unzip: <T>(array: ArrayLike<ArrayLike<T>> | T[][] | null | undefined) => T[][];
    readonly unzipWith: {
        <T, TResult>(array: ArrayLike<ArrayLike<T>> | null | undefined, iteratee: (...values: T[]) => TResult): TResult[];
        <T>(array: ArrayLike<ArrayLike<T>> | null | undefined): T[][];
    };
    readonly update: (object: object, path: lodash.Many<PropertyKey>, updater: (value: any) => any) => any;
    readonly updateWith: {
        <T extends object>(object: T, path: lodash.Many<PropertyKey>, updater: (oldValue: any) => any, customizer?: lodash.SetWithCustomizer<T> | undefined): T;
        <T extends object, TResult>(object: T, path: lodash.Many<PropertyKey>, updater: (oldValue: any) => any, customizer?: lodash.SetWithCustomizer<T> | undefined): TResult;
    };
    readonly upperCase: (string?: string | undefined) => string;
    readonly upperFirst: (string?: string | undefined) => string;
    readonly values: {
        <T>(object: lodash.Dictionary<T> | lodash.NumericDictionary<T> | ArrayLike<T> | null | undefined): T[];
        <T extends object>(object: T | null | undefined): T[keyof T][];
        (object: any): any[];
    };
    readonly without: <T>(array: ArrayLike<T> | null | undefined, ...values: T[]) => T[];
    readonly words: {
        (string?: string | undefined, pattern?: string | RegExp | undefined): string[];
        (string: string, index: string | number, guard: object): string[];
    };
    readonly xor: <T>(...arrays: (ArrayLike<T> | null | undefined)[]) => T[];
    readonly xorBy: {
        <T>(arrays: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined): T[];
        <T>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, iteratee?: string | [string, any] | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | undefined): T[];
        <T>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, arrays3: ArrayLike<T> | null | undefined, ...iteratee: (string | [string, any] | ArrayLike<T> | ((value: T) => lodash.NotVoid) | lodash.PartialDeep<T> | null | undefined)[]): T[];
    };
    readonly xorWith: {
        <T>(arrays: ArrayLike<T> | null | undefined, comparator?: lodash.Comparator<T> | undefined): T[];
        <T>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, comparator?: lodash.Comparator<T> | undefined): T[];
        <T>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, arrays3: ArrayLike<T> | null | undefined, ...comparator: (ArrayLike<T> | lodash.Comparator<T> | null | undefined)[]): T[];
    };
    readonly zip: <T>(...arrays: (ArrayLike<T> | null | undefined)[]) => T[][];
    readonly zipObject: {
        <T>(props: ArrayLike<PropertyKey>, values: ArrayLike<T>): lodash.Dictionary<T>;
        (props?: ArrayLike<PropertyKey> | undefined): lodash.Dictionary<undefined>;
    };
    readonly zipObjectDeep: (paths?: ArrayLike<lodash.Many<PropertyKey>> | undefined, values?: ArrayLike<any> | undefined) => object;
    readonly zipWith: {
        <T>(...arrays: (ArrayLike<T> | null | undefined)[]): T[][];
        <T, TResult>(arrays: ArrayLike<T> | null | undefined, iteratee: (value1: T) => TResult): TResult[];
        <T, TResult>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, iteratee: (value1: T, value2: T) => TResult): TResult[];
        <T, TResult>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, arrays3: ArrayLike<T> | null | undefined, iteratee: (value1: T, value2: T, value3: T) => TResult): TResult[];
        <T, TResult>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, arrays3: ArrayLike<T> | null | undefined, arrays4: ArrayLike<T> | null | undefined, iteratee: (value1: T, value2: T, value3: T, value4: T) => TResult): TResult[];
        <T, TResult>(arrays: ArrayLike<T> | null | undefined, arrays2: ArrayLike<T> | null | undefined, arrays3: ArrayLike<T> | null | undefined, arrays4: ArrayLike<T> | null | undefined, arrays5: ArrayLike<T> | null | undefined, iteratee: (value1: T, value2: T, value3: T, value4: T, value5: T) => TResult): TResult[];
        <T, TResult>(...iteratee: (((...group: T[]) => TResult) | ArrayLike<T> | null | undefined)[]): TResult[];
    };
};
export default _default;
