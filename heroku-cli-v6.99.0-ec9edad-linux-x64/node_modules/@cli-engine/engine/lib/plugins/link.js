"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_ux_1 = require("cli-ux");
const fs = require("fs-extra");
const path = require("path");
const rwlockfile_1 = require("rwlockfile");
const ts_lodash_1 = require("ts-lodash");
const deps_1 = require("../deps");
const plugin_1 = require("./plugin");
function touch(f) {
    fs.utimesSync(f, new Date(), new Date());
}
function pjsonPath(root) {
    return path.join(root, 'package.json');
}
function linkPJSON(root) {
    return deps_1.default.file.readJSON(pjsonPath(root));
}
function getNewestJSFile(root) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let files = yield deps_1.default.file.walk(root, {
            depthLimit: 20,
            filter: f => !['.git', 'node_modules'].includes(path.basename(f)),
        });
        return files.reduce((prev, f) => {
            if (f.stats.isDirectory())
                return prev;
            if (f.path.endsWith('.js') || f.path.endsWith('.ts')) {
                if (f.stats.mtime > prev) {
                    return f.stats.mtime;
                }
            }
            return prev;
        }, new Date(0));
    });
}
class NoCommandsError extends Error {
    constructor(name) {
        super(`${name} has no commands. Is this a CLI plugin?`);
        this.code = 'ENOCOMMANDS';
    }
}
exports.NoCommandsError = NoCommandsError;
class LinkPlugins {
    constructor(config) {
        this.config = config;
        this.debug = require('debug')('cli:plugins:user');
        this.manifest = new deps_1.default.PluginManifest({
            name: 'link',
            file: path.join(this.config.dataDir, 'plugins', 'link.json'),
        });
        this.lock = new rwlockfile_1.default(this.manifest.file, { ifLocked: () => cli_ux_1.default.action.start('Link plugins updating') });
    }
    install(root) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            cli_ux_1.default.action.start(`Linking ${root}`);
            yield this.init();
            try {
                yield this.lock.add('write', { reason: 'install' });
                yield this.addPlugin(root);
                // TODO: if (!commands.length) throw new NoCommandsError(this.name)
                cli_ux_1.default.action.stop();
            }
            finally {
                yield this.lock.remove('write');
            }
        });
    }
    uninstall(nameOrRoot) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let plugins = yield this.manifestPlugins();
            let deleted;
            if (nameOrRoot in plugins) {
                delete plugins[nameOrRoot];
                deleted = nameOrRoot;
            }
            else {
                const root = path.resolve(nameOrRoot);
                for (let name of Object.keys(plugins)) {
                    if (root === path.resolve(plugins[name].root)) {
                        delete plugins[name];
                        deleted = name;
                    }
                }
            }
            if (!deleted)
                return false;
            yield this.manifest.set('plugins', plugins);
            yield this.manifest.save();
            yield deps_1.default.file.remove(path.join(this.config.dataDir, 'plugins', 'link', `${deleted}.json`));
            delete this.plugins;
            return true;
        });
    }
    findByRoot(root) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.init();
            root = path.resolve(root);
            return this.plugins && this.plugins.find(p => path.resolve(p.root) === root);
        });
    }
    submanagers() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.init();
            return this.plugins;
        });
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.migrate();
            if (!this.plugins && (yield this.hasPlugins()))
                yield this._init();
        });
    }
    hasPlugins() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (yield deps_1.default.file.exists(this.manifest.file))
                return true;
            this.debug('no link plugins');
            return false;
        });
    }
    _init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.plugins)
                return;
            this.debug('init');
            const manifest = yield this.manifestPlugins();
            this.plugins = ts_lodash_1.default.compact(yield Promise.all(deps_1.default.util.objEntries(manifest).map(([k, v]) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                let plugin = yield this.loadPlugin(v.root).catch(err => {
                    cli_ux_1.default.warn(err);
                    return null;
                });
                if (plugin && plugin.name !== k) {
                    delete manifest[k];
                    manifest[plugin.name] = v;
                    yield this.manifest.set('plugins', manifest);
                    yield this.manifest.save();
                }
                return plugin;
            }))));
            if (this.plugins.length)
                this.debug('plugins:', this.plugins.map(p => p.name).join(', '));
        });
    }
    migrate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const linkedPath = path.join(this.config.dataDir, 'linked_plugins.json');
            if (!(yield deps_1.default.file.exists(linkedPath)))
                return;
            try {
                yield this.lock.add('write', { reason: 'migrate' });
                cli_ux_1.default.action.start('migrating link plugins');
                let linked = yield deps_1.default.file.readJSON(linkedPath);
                for (let root of linked.plugins) {
                    cli_ux_1.default.action.status = root;
                    yield this.addPlugin(root);
                }
                cli_ux_1.default.action.stop();
                yield deps_1.default.file.remove(linkedPath);
            }
            finally {
                yield this.lock.remove('write');
            }
        });
    }
    addPlugin(root) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const plugin = yield this.loadPlugin(root, true);
            if (!plugin)
                return;
            yield plugin.load();
            let plugins = yield this.manifestPlugins();
            plugins[plugin.name] = { root };
            yield this.manifest.set('plugins', plugins);
            yield this.manifest.save();
            delete this.plugins;
        });
    }
    manifestPlugins() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.manifest.get('plugins')) || {};
        });
    }
    loadPlugin(root, refresh = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!(yield deps_1.default.file.exists(root)))
                return;
            let p = new LinkPlugin({
                config: this.config,
                root,
                pjson: yield linkPJSON(root),
                type: 'link',
            });
            yield p.refresh(refresh);
            return p;
        });
    }
}
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'write')
], LinkPlugins.prototype, "install", null);
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'write')
], LinkPlugins.prototype, "uninstall", null);
exports.LinkPlugins = LinkPlugins;
class LinkPlugin extends plugin_1.Plugin {
    constructor(opts) {
        super(opts);
        this.type = 'link';
        this.manifest = new deps_1.default.PluginManifest({
            name: 'link',
            file: path.join(this.config.dataDir, 'plugins', 'link', `${this.name}.json`),
        });
    }
    refresh(force = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (force || (yield this.updateNodeModulesNeeded()))
                yield this.updateNodeModules();
            else if (yield this.prepareNeeded())
                yield this.prepare();
            deps_1.default.validate.pluginPjson(this.pjson, pjsonPath(this.root));
        });
    }
    reset() {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield _super("reset").call(this, true);
            yield this.manifest.set('lastUpdated', new Date().toISOString());
            yield this.manifest.save();
        });
    }
    updateNodeModulesNeeded() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // if ((await this.yarnNodeVersion()) !== process.version) return true
            let modules = path.join(this.root, 'node_modules');
            if (!(yield deps_1.default.file.exists(modules)))
                return true;
            let modulesInfo = yield fs.stat(modules);
            let pjsonInfo = yield fs.stat(path.join(this.root, 'package.json'));
            return modulesInfo.mtime < pjsonInfo.mtime;
        });
    }
    prepareNeeded() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const main = this.pjson.main;
            if (main && !(yield deps_1.default.file.exists(path.join(this.root, main))))
                return true;
            return (yield this.lastUpdated()) < (yield getNewestJSFile(this.root));
        });
    }
    updateNodeModules() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!cli_ux_1.default.action.running) {
                cli_ux_1.default.action.start(`Refreshing linked plugin ${this.name}`, 'yarn install');
            }
            this.debug('update node modules');
            const yarn = new deps_1.default.Yarn({ config: this.config, cwd: this.root });
            yield yarn.exec();
            yield this.prepare();
            touch(path.join(this.root, 'node_modules'));
            yield this.reset();
        });
    }
    prepare() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!cli_ux_1.default.action.running) {
                cli_ux_1.default.action.start(`Refreshing linked plugin ${this.name}`, 'yarn run prepare');
            }
            const { scripts } = this.pjson;
            const yarn = new deps_1.default.Yarn({ config: this.config, cwd: this.root });
            if (scripts && scripts.prepare)
                yield yarn.exec(['run', 'prepare']);
            if (scripts && scripts.prepublishOnly)
                yield yarn.exec(['run', 'prepublishOnly']);
            yield this.reset();
        });
    }
    lastUpdated() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const lastUpdated = yield this.manifest.get('lastUpdated');
            return lastUpdated ? new Date(lastUpdated) : new Date(0);
        });
    }
}
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'read')
], LinkPlugin.prototype, "refresh", null);
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'write')
], LinkPlugin.prototype, "reset", null);
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'write')
], LinkPlugin.prototype, "updateNodeModules", null);
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'write')
], LinkPlugin.prototype, "prepare", null);
exports.LinkPlugin = LinkPlugin;
