"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_ux_1 = require("cli-ux");
const path = require("path");
const ts_lodash_1 = require("ts-lodash");
const deps_1 = require("../deps");
const builtin_1 = require("./builtin");
const core_1 = require("./core");
const link_1 = require("./link");
const main_1 = require("./main");
const user_1 = require("./user");
class Plugins {
    constructor(config) {
        this.config = config;
        this.debug = require('debug')('cli:plugins');
        this.builtin = new builtin_1.Builtin(this.config);
        if (config.commandsDir) {
            this.main = new main_1.MainPlugin(this.config);
        }
        if (config.corePlugins) {
            this.core = new core_1.CorePlugins(this.config);
        }
        if (config.userPluginsEnabled) {
            this.user = new user_1.UserPlugins(this.config);
            this.link = new link_1.LinkPlugins(this.config);
        }
    }
    submanagers() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return ts_lodash_1.default.compact([this.builtin, this.main, this.core, this.user, this.link]);
        });
    }
    install(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.init();
            let name = options.type === 'user' ? options.name : yield this.getLinkedPackageName(options.root);
            let currentType = yield this.pluginType(name);
            if (currentType) {
                if (!options.force) {
                    throw new Error(`${name} is already installed, run with --force to install anyway`);
                }
                else if (['link', 'user'].includes(currentType)) {
                    yield this.uninstall(name);
                }
            }
            if (options.type === 'link') {
                yield this.link.install(options.root);
            }
            else {
                yield this.user.install(name, options.tag);
            }
        });
    }
    update() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.user.update();
        });
    }
    uninstall(name) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.init();
            let user = yield this.user.uninstall(name);
            let link = yield this.link.uninstall(name);
            if (!user && !link)
                throw new Error(`${name} is not installed`);
            cli_ux_1.default.action.stop();
        });
    }
    list() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.init();
            return this.plugins;
        });
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.plugins)
                return;
            const managers = ts_lodash_1.default.compact([this.core, this.user, this.link]);
            yield Promise.all(managers.map(m => m.init()));
            const plugins = managers.reduce((o, i) => o.concat(i.plugins), []);
            this.plugins = ts_lodash_1.default.compact([...plugins, this.builtin]);
        });
    }
    getLinkedPackageName(root) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pjson = yield deps_1.default.file.fetchJSONFile(path.join(root, 'package.json'));
            return pjson.name;
        });
    }
    pluginType(name) {
        const plugin = this.plugins.find(p => p.name === name);
        return plugin && plugin.type;
    }
}
exports.Plugins = Plugins;
